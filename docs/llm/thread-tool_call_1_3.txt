

--- title: Tool Calling description: Learn about tool calling and multi-step calls (using stopWhen) with AI SDK Core. --- # Tool Calling As covered under Foundations, [tools](/docs/foundations/tools) are objects that can be called by the model to perform a specific task. AI SDK Core tools contain

pasted

AI SDK v5 æœ‰æä¾› tool, mcp tool
åœ¨ç›¡å¯èƒ½åˆ©ç”¨AI SDK native methods, types çš„å‰æä¸‹ï¼Œæ€è€ƒå¦‚ä½•é‡æ§‹too-call
è«‹ä»¥æˆ‘å€‘ç›®å‰è¨è«–çš„ thread-tool_call_1_2.txt ç‚ºåŸºç¤
è®“æˆ‘å€‘å…ˆè¨è«– packages/events-core/src/services/tool-call/types.ts ï¼Œè«‹å»ºè­°é‡æ§‹æ–¹æ¡ˆ

Edit

é‡æ§‹ tool-callï¼Œåˆ©ç”¨ AI SDK v5 åŸç”Ÿæ–¹æ³•å’Œé¡å‹
4s





Searched project for â€œthread-tool_call_1_2.txt tool call types architectureâ€
2 results





è§£æ tool call æ¶æ§‹ï¼Œè¿½è¹¤ç‹€æ…‹å’Œè¨­è¨ˆæ–¹æ¡ˆ
7s





Searched project for â€œpackages/events-core/src/services/tool-call/types.ts current tool call types definitionsâ€
6 results










Analyzed AI SDK v5 tool-call types for comprehensive refactoring
11s





åŸºäºå½“å‰çš„ types.ts æ–‡ä»¶åˆ†æå’Œ AI SDK v5 çš„èƒ½åŠ›ï¼Œæˆ‘æ¥æä¾›ä¸€ä¸ªç³»ç»Ÿæ€§çš„é‡æ„æ–¹æ¡ˆï¼š

Tool-Call Types é‡æ„ç­–ç•¥åˆ†æ
å½“å‰ç±»å‹çš„ AI SDK å¯¹åº”å…³ç³»
è®©æˆ‘ç³»ç»Ÿæ€§åˆ†ææ¯ä¸ªè‡ªå®šä¹‰ç±»å‹æ˜¯å¦èƒ½ç”¨ AI SDK åŸç”Ÿç±»å‹æ›¿æ¢ï¼š

ğŸ”„ å¯å®Œå…¨æ›¿æ¢çš„ç±»å‹
typescript
// âŒ å½“å‰è‡ªå®šç¾©
interface Tool {
  name: string;
  description: string;
  inputSchema: unknown;
  shouldConfirmExecute(...): Promise<...>;
  execute(...): Promise<unknown>;
}

// âœ… æ”¹ç”¨ AI SDK åŸç”Ÿ
import type { Tool } from 'ai';
typescript
// âŒ å½“å‰è‡ªå®šç¾©  
interface ToolCallRequestInfo {
  callId: string;
  name: string;
  args: Record<string, unknown>;
}

// âœ… æ”¹ç”¨ AI SDK åŸç”Ÿ
import type { ToolCallUnion } from 'ai';
// ToolCallUnion<TOOLS> åŒ…å«ï¼štoolCallId, toolName, input
typescript
// âŒ å½“å‰è‡ªå®šç¾©
interface ToolCallResponseInfo {
  callId: string;
  result: unknown;
  error: string | null;
  timestamp: Date;
}

// âœ… æ”¹ç”¨ AI SDK åŸç”Ÿ
import type { ToolResultUnion } from 'ai';
// ToolResultUnion<TOOLS> åŒ…å«ï¼štoolCallId, toolName, result
âœ… éœ€è¦ä¿ç•™çš„æ¥­å‹™é¡å‹
typescript
// âœ… ä¿ç•™ - æ¥­å‹™ç‰¹å®šçš„ç‹€æ…‹æ©Ÿ
export type ToolCallStatus = 
  | "validating" | "scheduled" | "executing" 
  | "success" | "error" | "cancelled" | "awaiting_approval";

// âœ… ä¿ç•™ - ç¢ºèªæ¥­å‹™é‚è¼¯
export type ConfirmationOutcome = "yes" | "yes_always" | "no";

// âœ… ä¿ç•™ - åŸ·è¡Œä¸Šä¸‹æ–‡
export interface ExecutionContext {
  chatId: string;
  messageId: string;
  projectPath?: string;
  userId?: string;
}
â“ éœ€è¦é‡æ–°è¨­è¨ˆçš„é¡å‹
ç•¶å‰çš„ discriminated unionï¼ˆValidatingToolCall, ScheduledToolCall ç­‰ï¼‰éæ–¼è¤‡é›œï¼Œå¯ä»¥ç°¡åŒ–ç‚ºçµ±ä¸€çµæ§‹ã€‚

é‡æ§‹è¨­è¨ˆæ–¹æ¡ˆ
A. æ¥µç°¡åŒ–çš„é¡å‹å®šç¾©
typescript
// tool-call/types.ts
import type {
  Tool,                    // âŒ å–ä»£è‡ªå®šç¾© Tool interface
  ToolSet,                 // âŒ ç›´æ¥ä½¿ç”¨
  ToolCallUnion,          // âŒ å–ä»£ ToolCallRequestInfo
  ToolResultUnion,        // âŒ å–ä»£ ToolCallResponseInfo
  ToolChoice,             // æ–°å¢ï¼šå·¥å…·é¸æ“‡ç­–ç•¥
} from 'ai';

// âœ… ä¿ç•™æ¥­å‹™ç‰¹å®šç‹€æ…‹
export type ToolCallStatus = 
  | "validating" | "scheduled" | "executing" 
  | "success" | "error" | "cancelled" | "awaiting_approval";

export type ConfirmationOutcome = "yes" | "yes_always" | "no";

// âŒ æ›¿æ›è¤‡é›œçš„ discriminated union ç‚ºçµ±ä¸€çµæ§‹
export interface ToolCallExecution<TOOLS extends ToolSet> {
  // ç›´æ¥ä½¿ç”¨ AI SDK åŸç”Ÿé¡å‹
  toolCall: ToolCallUnion<TOOLS>;           // å–ä»£ ToolCallRequestInfo
  
  // æ¥­å‹™ç‹€æ…‹ç®¡ç†
  status: ToolCallStatus;
  startTime?: number;
  endTime?: number;
  durationMs?: number;
  
  // åŸ·è¡Œçµæœï¼ˆAI SDK åŸç”Ÿï¼‰
  result?: ToolResultUnion<TOOLS>;          // å–ä»£ ToolCallResponseInfo
  error?: string;
  
  // ç¢ºèªæµç¨‹
  needsConfirmation?: boolean;
  confirmationOutcome?: ConfirmationOutcome;
  liveOutput?: string;                      // ç”¨æ–¼ streaming
}
B. æ‰¹æ¬¡ç¢ºèªåŸ·è¡Œçš„æ¶æ§‹
åŸºæ–¼ AI SDK åŸç”Ÿé¡å‹çš„æ‰¹æ¬¡åŸ·è¡Œè¨­è¨ˆï¼š

typescript
// æ‰¹æ¬¡åŸ·è¡Œç‹€æ…‹ç®¡ç†
export interface ToolCallBatch<TOOLS extends ToolSet> {
  batchId: string;
  messageId: string;
  executions: ToolCallExecution<TOOLS>[];
  
  // æ‰¹æ¬¡ç‹€æ…‹
  isComplete: boolean;
  allApproved: boolean;
  hasFailures: boolean;
}

// ç¢ºèªè¨˜éŒ„ï¼ˆç”¨æ–¼å»ºç«‹ policiesï¼‰
export interface ToolCallConfirmation {
  toolCallId: string;
  outcome: ConfirmationOutcome;
  timestamp: Date;
  batchId: string;
}

// è‡ªå‹•æ‰¹å‡†æ”¿ç­–ï¼ˆå¾ç¢ºèªæ­·å²æ´¾ç”Ÿï¼‰
export interface ToolApprovalPolicy {
  toolName: string;
  createdAt: Date;
  sourceConfirmationId: string;
}
C. ToolCallRunner æ¥å£ç°¡åŒ–
åŸºæ–¼ AI SDK åŸç”Ÿé¡å‹çš„ runner è¨­è¨ˆï¼š

typescript
// åŸ·è¡Œçµæœå®Œå…¨åŸºæ–¼ AI SDK åŸç”Ÿé¡å‹
export interface ToolExecutionResult<TOOLS extends ToolSet> {
  executed: ToolResultUnion<TOOLS>[];           // AI SDK åŸç”Ÿ
  stillNeedsApproval: ToolCallUnion<TOOLS>[];   // AI SDK åŸç”Ÿ
  failed: Array<{
    toolCall: ToolCallUnion<TOOLS>;            // AI SDK åŸç”Ÿ
    error: string;
  }>;
}

// Runner æ¥å£ï¼ˆå®Œå…¨ statelessï¼‰
interface IToolCallRunner<TOOLS extends ToolSet> {
  execute(
    toolCalls: ToolCallUnion<TOOLS>[],          // AI SDK åŸç”Ÿè¼¸å…¥
    confirmations: ToolCallConfirmation[],       // å®Œæ•´ç¢ºèªæ­·å²
    context: ExecutionContext
  ): Promise<ToolExecutionResult<TOOLS>>;
}
é‡æ§‹å„ªå‹¢åˆ†æ
1. é¡å‹ä¸€è‡´æ€§æœ€å¤§åŒ–
é›¶é˜»æŠ—è½‰æ›ï¼šstreamText() ç”¢ç”Ÿçš„ ToolCallUnion<TOOLS> ç›´æ¥å‚³çµ¦ ToolCallRunner
è‡ªå‹•å…¼å®¹ï¼šAI SDK æ›´æ–°æ™‚è‡ªå‹•ç²å¾—æ–°åŠŸèƒ½
é¡å‹å®‰å…¨ï¼šç·¨è­¯æ™‚ç¢ºä¿èˆ‡ AI SDK å®Œå…¨å…¼å®¹
2. ç¶­è­·è² æ“”æœ€å°åŒ–
åˆªé™¤ 80% è‡ªå®šç¾©é¡å‹ï¼šä¸å†ç¶­è­·é‡è¤‡çš„é¡å‹å®šç¾©
ç°¡åŒ–ç‹€æ…‹ç®¡ç†ï¼šå¾è¤‡é›œ discriminated union æ”¹ç‚ºçµ±ä¸€çµæ§‹
é›†ä¸­é‚è¼¯ï¼šæ‰€æœ‰ç¢ºèªé‚è¼¯å°è£åœ¨ ToolCallRunner
3. æ‰¹æ¬¡ç¢ºèªå®‰å…¨æ©Ÿåˆ¶
å®ˆé–€å“¡æª¢æŸ¥ï¼šallCallsFinalOrScheduled ç¢ºä¿æ‰€æœ‰å·¥å…·éƒ½ç²å¾—æ±ºå®š
åŸå­æ€§åŸ·è¡Œï¼šè¦å˜›å…¨éƒ¨åŸ·è¡Œï¼Œè¦å˜›å…¨éƒ¨ç­‰å¾…
ç‹€æ…‹è¿½è¹¤ï¼šæ¸…æ™°çš„æ‰¹æ¬¡ç‹€æ…‹ç®¡ç†
4. MVP å‹å¥½
çŠ§ç‰²å°‘é‡æ€§èƒ½æ›å–å¤§å¹…ç°¡åŒ–ï¼šæ¯æ¬¡é‡æ–°è¨ˆç®— policies
æ˜“æ–¼ç†è§£å’Œä¿®æ”¹ï¼šé‚è¼¯é›†ä¸­ï¼Œè·è²¬æ¸…æ™°
æ¸¬è©¦ç°¡åŒ–ï¼šstateless runnerï¼Œè¼¸å…¥å®Œå…¨ç¢ºå®š
è¨­è¨ˆå–æ¨èªªæ˜
æ€§èƒ½ vs ç°¡æ½”æ€§ï¼šé¸æ“‡æ¯æ¬¡é‡æ–°è¨ˆç®— policiesï¼Œé¿å…ç‹€æ…‹åŒæ­¥è¤‡é›œæ€§

è·è²¬åˆ†é›¢ç¨‹åº¦ï¼šChatSession è®Šæˆç´”å„²å­˜å®¹å™¨ï¼ŒToolCallRunner åŒ…å«æ‰€æœ‰ tool call é‚è¼¯

é¡å‹ç³»çµ±ï¼šæœ€å¤§åŒ–ä½¿ç”¨ AI SDK åŸç”Ÿé¡å‹ï¼Œåªä¿ç•™å¿…è¦çš„æ¥­å‹™é¡å‹

é€™å€‹è¨­è¨ˆå¯¦ç¾äº†ã€Œæœ€å¤§åŒ– AI SDK åŸç”Ÿé¡å‹ä½¿ç”¨ + æœ€å°åŒ–æ¶æ§‹è¤‡é›œåº¦ + æ”¯æŒæ‰¹æ¬¡ç¢ºèªåŸ·è¡Œã€çš„ç›®æ¨™ï¼Œéå¸¸é©åˆ MVP éšæ®µçš„å¿«é€Ÿé–‹ç™¼éœ€æ±‚ã€‚




Retry

import type { ToolSet, ToolCallUnion, ToolResultUnion } from "ai"; import type { ToolRegistry } from "./tool-registry.js"; import type { IEventBus } from "../../event-bus.js"; export type ToolCallConfirmationOutcome = "yes" | "yes_always" | "no"; export interface ToolCallConfirmation { toolCallI

pasted

tool call types å¯åƒè€ƒæˆ‘å€‘è¨è«–çš„æœ€æ–°è¨­è¨ˆï¼ˆé‚„åœ¨é–‹ç™¼ä¸­

Edit

åˆ†ææœ€æ–°å·¥å…·èª¿ç”¨è¨­è¨ˆï¼Œè©•ä¼°é‡æ§‹æ–¹æ¡ˆå’Œå„ªåŒ–ç­–ç•¥
7s




çœ‹åˆ°ä½ å·²ç¶“é–‹å§‹å¯¦æ–½æˆ‘å€‘è¨è«–çš„è¨­è¨ˆæ–¹æ¡ˆï¼é€™å€‹å¯¦ç¾å¾ˆå¥½åœ°é«”ç¾äº†æˆ‘å€‘çš„é‡æ§‹åŸå‰‡ã€‚è®“æˆ‘åˆ†æä¸€ä¸‹é€™å€‹è¨­è¨ˆï¼š

è¨­è¨ˆåˆ†æ - å„ªç§€çš„å¯¦ç¾
âœ… AI SDK åŸç”Ÿé¡å‹ä½¿ç”¨å¾—å¾ˆå¥½
typescript
import type { ToolSet, ToolCallUnion, ToolResultUnion } from "ai";
é€™å€‹å®Œç¾é«”ç¾äº†æˆ‘å€‘ã€Œæœ€å¤§åŒ–ä½¿ç”¨ AI SDK åŸç”Ÿé¡å‹ã€çš„åŸå‰‡ï¼š

é›¶é˜»æŠ—è½‰æ›ï¼šç›´æ¥ä½¿ç”¨ ToolCallUnion<TOOLS> å’Œ ToolResultUnion<TOOLS>
é¡å‹å®‰å…¨ï¼šèˆ‡ AI SDK å®Œå…¨å…¼å®¹
æœªä¾†å…¼å®¹ï¼šAI SDK æ›´æ–°æ™‚è‡ªå‹•ç²ç›Š
âœ… æ‰¹æ¬¡ç¢ºèªå®‰å…¨æ©Ÿåˆ¶æ­£ç¢ºå¯¦ç¾
typescript
const allDecided = toolsWithStatus.every(
  (t) => t.status !== "awaiting_approval",
);

if (!allDecided) {
  return {
    status: "waiting_confirmations",
    pendingToolCalls: toolsWithStatus
      .filter((t) => t.status === "awaiting_approval")
      .map((t) => t.toolCall),
  };
}
é€™å€‹ã€Œå®ˆé–€å“¡ã€æª¢æŸ¥å®Œç¾å¯¦ç¾äº†æˆ‘å€‘è¨è«–çš„å®‰å…¨è¦æ±‚ï¼šæ‰€æœ‰å·¥å…·éƒ½æ±ºå®šäº†æ‰é–‹å§‹åŸ·è¡Œ

âœ… ç°¡åŒ–çš„ç‹€æ…‹ç®¡ç†
ä¸å†ä½¿ç”¨è¤‡é›œçš„ discriminated unionï¼Œæ”¹ç”¨ç°¡æ½”çš„çµ±ä¸€çµæ§‹ï¼š

typescript
export interface ToolWithStatus<TOOLS extends ToolSet> {
  toolCall: ToolCallUnion<TOOLS>;    // AI SDK åŸç”Ÿ
  status: ToolExecutionStatus;       // æ¥­å‹™ç‹€æ…‹
  result?: ToolResultUnion<TOOLS>;   // AI SDK åŸç”Ÿ
}
è¨­è¨ˆå»ºè­°èˆ‡å„ªåŒ–
A. Always Allow è¦å‰‡çš„é—œè¯è¨­è¨ˆ
ç•¶å‰è¨­è¨ˆå¾ˆå¥½ï¼Œå»ºè­°å°èª¿æ•´ä¾†è¿½è¹¤ä¾†æºï¼š

typescript
export interface ToolAlwaysAllowRule {
  toolName: string;
  sourceConfirmation: ToolCallConfirmation;  // âœ… è¿½è¹¤ä¾†æºå¾ˆå¥½
  createdAt: Date;  // å»ºè­°ï¼šæ·»åŠ å‰µå»ºæ™‚é–“
}
B. ToolCallRunner çš„è·è²¬åˆ†é›¢å®Œç¾
typescript
// âœ… å®Œç¾çš„ stateless service è¨­è¨ˆ
class ToolCallRunner<TOOLS extends ToolSet> {
  constructor(
    private toolRegistry: ToolRegistry,  // ä¾è³´æ³¨å…¥
    private eventBus: IEventBus,
  ) {}
  
  // âœ… æ¯æ¬¡èª¿ç”¨éƒ½æ˜¯ç¨ç«‹çš„ï¼Œå®Œå…¨åŸºæ–¼è¼¸å…¥åƒæ•¸
  async execute(
    toolCalls: ToolCallUnion<TOOLS>[],     // AI SDK åŸç”Ÿ
    confirmations: ToolCallConfirmation[], // å®Œæ•´æ­·å²
    alwaysAllowRules: ToolAlwaysAllowRule[], // æ´¾ç”Ÿè¦å‰‡
    context: ToolExecutionContext,
  ): Promise<ToolExecutionResult<TOOLS>>
}
é€™å€‹è¨­è¨ˆå®Œç¾é«”ç¾äº†æˆ‘å€‘è¨è«–çš„ï¼š

ChatSession: ç´”å„²å­˜ + å§”è¨—
ToolCallRunner: åŒ…å«æ‰€æœ‰ tool call é‚è¼¯ï¼Œä½† stateless
C. ToolExecutionResult çš„é¡å‹è¨­è¨ˆå„ªåŒ–
ç•¶å‰çš„ discriminated union è¨­è¨ˆå¾ˆå¥½ï¼Œå»ºè­°å°èª¿æ•´ï¼š

typescript
export type ToolExecutionResult<TOOLS extends ToolSet> =
  | {
      status: "waiting_confirmations";
      pendingToolCalls: ToolCallUnion<TOOLS>[];
      // å»ºè­°ï¼šæ·»åŠ å·²æ±ºå®šçš„å·¥å…·ä¿¡æ¯
      decidedToolCalls?: ToolWithStatus<TOOLS>[];
    }
  | {
      status: "completed";
      executed: ToolResultUnion<TOOLS>[];
      // å»ºè­°ï¼šæ·»åŠ å¤±æ•—ä¿¡æ¯
      failed?: Array<{ 
        toolCall: ToolCallUnion<TOOLS>; 
        error: string; 
      }>;
    };
D. èˆ‡ ChatSession çš„æ•´åˆæ¨¡å¼
åŸºæ–¼é€™å€‹è¨­è¨ˆï¼ŒChatSession çš„ä½¿ç”¨æ¨¡å¼æœƒæ˜¯ï¼š

typescript
// chat-session.ts
export class ChatSession<TOOLS extends ToolSet> {
  // âœ… æ¥µç°¡ç‹€æ…‹ç®¡ç†
  private toolCallConfirmations: ToolCallConfirmation[] = [];
  private toolAlwaysAllowRules: ToolAlwaysAllowRule[] = [];
  
  async runTurn(input: TurnInput<TOOLS>) {
    // æ”¶é›† AI å›æ‡‰ä¸­çš„ tool calls
    const toolCalls: ToolCallUnion<TOOLS>[] = []; // å¾ streamText æ”¶é›†
    
    // âœ… å§”è¨—çµ¦ runnerï¼Œå‚³å…¥å®Œæ•´ç‹€æ…‹
    const result = await this.toolCallRunner.execute(
      toolCalls,
      this.toolCallConfirmations,      // å®Œæ•´ç¢ºèªæ­·å²
      this.toolAlwaysAllowRules,       // ç•¶å‰è¦å‰‡
      { chatId: this.id }
    );
    
    if (result.status === "waiting_confirmations") {
      // ç­‰å¾…ç”¨æˆ¶ç¢ºèª
      return { needsConfirmation: true, pendingTools: result.pendingToolCalls };
    }
    
    // åŸ·è¡Œå®Œæˆï¼Œæ›´æ–°å°è©±æ­·å²
    return { executed: result.executed };
  }
  
  // âœ… Session è™•ç†ç¢ºèªé‚è¼¯
  async confirmToolCall(toolCallId: string, outcome: ToolCallConfirmationOutcome) {
    const confirmation: ToolCallConfirmation = {
      toolCallId,
      outcome,
      timestamp: new Date()
    };
    
    this.toolCallConfirmations.push(confirmation);
    
    // âœ… è™•ç† "yes_always" é‚è¼¯
    if (outcome === "yes_always") {
      this.createAlwaysAllowRule(confirmation);
    }
  }
}
ç¸½é«”è©•åƒ¹
é€™å€‹å¯¦ç¾éå¸¸å„ªç§€ï¼Œå®Œç¾é«”ç¾äº†æˆ‘å€‘è¨è«–çš„æ‰€æœ‰é‡æ§‹åŸå‰‡ï¼š

AI SDK åŸç”Ÿé¡å‹æœ€å¤§åŒ–ä½¿ç”¨ âœ…
æ‰¹æ¬¡ç¢ºèªå®‰å…¨æ©Ÿåˆ¶ âœ…
è·è²¬åˆ†é›¢ï¼ˆSession å„²å­˜ + Runner é‚è¼¯ï¼‰ âœ…
é¡å‹ç°¡åŒ–ï¼ˆçµ±ä¸€çµæ§‹å–ä»£è¤‡é›œ discriminated unionï¼‰ âœ…
MVP å‹å¥½ï¼ˆç°¡æ½” > æ€§èƒ½ï¼‰ âœ…
é€™å€‹è¨­è¨ˆå°‡æˆç‚ºä¸€å€‹å„ªç§€çš„ tool call ç³»çµ±åŸºç¤ï¼Œæ—¢ä¿æŒäº†èˆ‡ AI SDK çš„å®Œç¾æ•´åˆï¼Œåˆæä¾›äº†å¿…è¦çš„æ¥­å‹™é‚è¼¯æ”¯æŒã€‚




Retry
æ¥ä¸‹ä¾†è«‹é‡å° packages/events-core/src/services/tool-call/tool-registry.ts çµ¦äºˆé‡æ§‹æ–¹æ¡ˆ
æœ€å¤§åŒ–ä½¿ç”¨ ai sdk v5

Edit

åˆ†æå·¥å…·æ³¨å†Œé‡æ„ï¼Œæ¢ç´¢ AI SDK v5 é›†æˆæ–¹æ¡ˆ
4s





Searched project for â€œpackages/events-core/src/services/tool-call/tool-registry.tsâ€
5 results









é‡æ„å·¥å…·æ³¨å†Œï¼Œä¼˜åŒ– AI SDK v5 é›†æˆæ–¹æ¡ˆ
7s






åŸºäº AI SDK v5 çš„ ToolRegistry é‡æ„æ–¹æ¡ˆï¼Œæˆ‘æ¥åˆ†æå½“å‰è®¾è®¡å¹¶æä¾›é‡æ„å»ºè®®ï¼š

å½“å‰è®¾è®¡åˆ†æ
âŒ éœ€è¦æ›¿æ¢çš„è‡ªå®šä¹‰é¡å‹
typescript
// ç•¶å‰è‡ªå®šç¾© Tool interface
export interface Tool {
  name: string;
  description: string;
  inputSchema: unknown;
  shouldConfirmExecute(...): Promise<...>;
  execute(...): Promise<unknown>;
}

// âŒ è‡ªå®šç¾© MCP å®¢æˆ¶ç«¯
interface MCPClient {
  listTools(): Promise<MCPToolInfo[]>;
  callTool(...): Promise<unknown>;
}
âœ… å¯ä»¥ä¿ç•™çš„æ¥­å‹™é‚è¼¯
å·¥å…·åˆ†é¡ç®¡ç†
å¥åº·ç›£æ§
äº‹ä»¶ç™¼é€
ç¢ºèªé‚è¼¯åŒ…è£
AI SDK v5 é‡æ§‹æ–¹æ¡ˆ
A. å®Œå…¨åŸºæ–¼ AI SDK åŸç”Ÿé¡å‹çš„è¨­è¨ˆ
typescript
// tool-registry.ts
import type { 
  Tool,                                    // âŒ ä½¿ç”¨ AI SDK åŸç”Ÿ Tool
  ToolSet,                                // âŒ ä½¿ç”¨ AI SDK åŸç”Ÿ ToolSet
  experimental_createMCPClient as createMCPClient  // âŒ ä½¿ç”¨ AI SDK MCP æ”¯æ´
} from 'ai';
import type { MCPClient } from 'ai/mcp';   // âŒ ä½¿ç”¨ AI SDK MCP é¡å‹

// âœ… ä¿ç•™æ¥­å‹™ç‰¹å®šé¡å‹
export interface ToolRegistrationMetadata {
  category: string;
  source: 'built-in' | 'mcp';
  serverName?: string;
  registeredAt: Date;
}

export interface ToolHealthStatus {
  isHealthy: boolean;
  lastChecked: Date;
  error?: string;
}

// âŒ å¤§å¹…ç°¡åŒ–çš„ Registry è¨­è¨ˆ
export class ToolRegistry {
  // âœ… ç›´æ¥ç®¡ç† AI SDK åŸç”Ÿ ToolSet
  private toolSet: ToolSet = {};
  private toolMetadata: Map<string, ToolRegistrationMetadata> = new Map();
  private toolHealth: Map<string, ToolHealthStatus> = new Map();
  private mcpClients: Map<string, MCPClient> = new Map();
  
  constructor(
    private eventBus: IEventBus,
    private logger: Logger<ILogObj>
  ) {}
B. å·¥å…·è¨»å†Šçš„æ¥µç°¡åŒ–è¨­è¨ˆ
typescript
// âœ… ç›´æ¥è¨»å†Š AI SDK åŸç”Ÿå·¥å…·
registerTool(tool: Tool<any, any>, metadata?: Partial<ToolRegistrationMetadata>): void {
  const toolName = this.extractToolName(tool);
  
  // âŒ ç›´æ¥æ·»åŠ åˆ° ToolSet
  this.toolSet[toolName] = tool;
  
  // âœ… ä¿ç•™æ¥­å‹™å…ƒæ•¸æ“š
  this.toolMetadata.set(toolName, {
    category: metadata?.category || 'built-in',
    source: 'built-in',
    registeredAt: new Date(),
    ...metadata
  });
  
  this.logger.info("Tool registered", { toolName, category: metadata?.category });
  
  this.eventBus.emit({
    kind: "TOOL_REGISTERED",
    toolName,
    toolType: "built-in",
    timestamp: new Date(),
  });
}

// âœ… ç²å–å®Œæ•´çš„ ToolSetï¼ˆä¾› AI SDK ä½¿ç”¨ï¼‰
getToolSet(): ToolSet {
  return this.toolSet;
}

// âœ… ç²å–å–®å€‹å·¥å…·ï¼ˆå‘å¾Œå…¼å®¹ï¼‰
getTool(name: string): Tool<any, any> | undefined {
  return this.toolSet[name];
}
C. MCP é›†æˆä½¿ç”¨ AI SDK åŸç”Ÿæ”¯æ´
typescript
// âŒ ä½¿ç”¨ AI SDK çš„ MCP æ”¯æ´
async registerMCPServer(serverConfig: MCPServerConfig): Promise<void> {
  this.logger.info("Registering MCP server with AI SDK", {
    serverName: serverConfig.name,
  });

  try {
    // âœ… ä½¿ç”¨ AI SDK åŸç”Ÿ MCP å®¢æˆ¶ç«¯
    const mcpClient = await createMCPClient({
      transport: {
        type: 'sse',  // æˆ– 'stdio'ï¼Œæ ¹æ“šé…ç½®
        url: serverConfig.url,
        headers: serverConfig.oauth?.enabled ? {
          Authorization: `Bearer ${await this.getOAuthToken(serverConfig)}`
        } : undefined
      }
    });

    // âŒ ç›´æ¥ç²å– AI SDK æ ¼å¼çš„å·¥å…·
    const tools = await mcpClient.tools();  // è¿”å› ToolSet æ ¼å¼
    
    // âœ… æ‰¹é‡è¨»å†Š MCP å·¥å…·
    Object.entries(tools).forEach(([toolName, tool]) => {
      // âŒ ç›´æ¥æ·»åŠ åˆ°ä¸» ToolSet
      this.toolSet[toolName] = tool;
      
      // âœ… è¨˜éŒ„ MCP ä¾†æº
      this.toolMetadata.set(toolName, {
        category: serverConfig.category || 'mcp',
        source: 'mcp',
        serverName: serverConfig.name,
        registeredAt: new Date()
      });
    });

    this.mcpClients.set(serverConfig.name, mcpClient);
    
    this.logger.info("MCP server registered", {
      serverName: serverConfig.name,
      toolCount: Object.keys(tools).length
    });

    this.eventBus.emit({
      kind: "MCP_SERVER_REGISTERED",
      serverName: serverConfig.name,
      toolCount: Object.keys(tools).length,
      timestamp: new Date(),
    });

  } catch (error) {
    this.logger.error("Failed to register MCP server", {
      serverName: serverConfig.name,
      error: error.message
    });
    throw error;
  }
}
D. æ¥­å‹™é‚è¼¯åŒ…è£å·¥å…·çš„ç­–ç•¥
å°æ–¼éœ€è¦ç¢ºèªé‚è¼¯çš„å·¥å…·ï¼Œä½¿ç”¨ AI SDK çš„æ“´å±•æ©Ÿåˆ¶ï¼š

typescript
// âœ… åŒ…è£ AI SDK å·¥å…·æ·»åŠ ç¢ºèªé‚è¼¯
wrapToolWithConfirmation<T extends Tool<any, any>>(
  tool: T, 
  confirmationLogic: (input: any) => Promise<boolean>
): Tool<any, any> {
  // âŒ ä½¿ç”¨ AI SDK çš„ tool helper å‰µå»ºåŒ…è£å·¥å…·
  return tool({
    description: tool.description,
    inputSchema: tool.inputSchema,
    execute: async (input, options) => {
      // âœ… æ·»åŠ ç¢ºèªé‚è¼¯
      const needsConfirmation = await confirmationLogic(input);
      if (needsConfirmation) {
        // æ‹‹å‡ºç‰¹æ®ŠéŒ¯èª¤ï¼Œè®“ä¸Šå±¤è™•ç†ç¢ºèªé‚è¼¯
        throw new ToolConfirmationRequired(tool.name, input);
      }
      
      // åŸ·è¡ŒåŸå§‹å·¥å…·
      return await tool.execute(input, options);
    }
  });
}

// âœ… æ‰¹é‡åŒ…è£å±éšªå·¥å…·
registerDangerousTool(tool: Tool<any, any>, dangerLevel: 'low' | 'medium' | 'high'): void {
  const wrappedTool = this.wrapToolWithConfirmation(
    tool,
    async (input) => this.assessDangerLevel(tool.name, input, dangerLevel)
  );
  
  this.registerTool(wrappedTool, { 
    category: 'dangerous',
    dangerLevel 
  });
}
E. å¥åº·ç›£æ§ç°¡åŒ–
typescript
// âœ… ç°¡åŒ–çš„å¥åº·æª¢æŸ¥
async checkToolHealth(): Promise<ToolHealthReport> {
  const healthResults = new Map<string, ToolHealthStatus>();
  
  // æª¢æŸ¥æ‰€æœ‰å·¥å…·
  for (const [toolName, tool] of Object.entries(this.toolSet)) {
    try {
      // âœ… ç°¡å–®çš„å¥åº·æª¢æŸ¥ - å˜—è©¦è¨ªå•å·¥å…·å±¬æ€§
      const isAccessible = tool && tool.description && tool.inputSchema;
      
      healthResults.set(toolName, {
        isHealthy: !!isAccessible,
        lastChecked: new Date(),
        error: isAccessible ? undefined : 'Tool properties not accessible'
      });
    } catch (error) {
      healthResults.set(toolName, {
        isHealthy: false,
        lastChecked: new Date(),
        error: error.message
      });
    }
  }
  
  // æª¢æŸ¥ MCP å®¢æˆ¶ç«¯
  const mcpHealth = await this.checkMCPClientHealth();
  
  return this.buildHealthReport(healthResults, mcpHealth);
}

private async checkMCPClientHealth(): Promise<Map<string, boolean>> {
  const mcpHealth = new Map<string, boolean>();
  
  for (const [serverName, client] of this.mcpClients) {
    try {
      // âœ… ä½¿ç”¨ AI SDK MCP å®¢æˆ¶ç«¯çš„å¥åº·æª¢æŸ¥
      await client.tools();  // å˜—è©¦ç²å–å·¥å…·åˆ—è¡¨
      mcpHealth.set(serverName, true);
    } catch (error) {
      this.logger.warn("MCP server health check failed", {
        serverName,
        error: error.message
      });
      mcpHealth.set(serverName, false);
    }
  }
  
  return mcpHealth;
}
F. èˆ‡ ChatSession çš„æ•´åˆ
typescript
// chat-session.ts
export class ChatSession<TOOLS extends ToolSet> {
  constructor(
    private toolRegistry: ToolRegistry,  // æ³¨å…¥ registry
    // ... å…¶ä»–ä¾è³´
  ) {}
  
  async runTurn(input: TurnInput) {
    // âŒ ç›´æ¥ç²å– AI SDK æ ¼å¼çš„ ToolSet
    const tools = this.toolRegistry.getToolSet() as TOOLS;
    
    const result = streamText({
      model: this.model,
      messages: this.getModelMessages(),
      tools,  // âŒ ç›´æ¥ä½¿ç”¨ï¼Œç„¡éœ€è½‰æ›
    });
    
    // è™•ç†å·¥å…·èª¿ç”¨...
  }
}
é‡æ§‹å„ªå‹¢åˆ†æ
1. AI SDK åŸç”Ÿé›†æˆæœ€å¤§åŒ–
é›¶è½‰æ›æˆæœ¬ï¼šç›´æ¥ä½¿ç”¨ AI SDK çš„ ToolSet æ ¼å¼
MCP åŸç”Ÿæ”¯æ´ï¼šä½¿ç”¨ experimental_createMCPClient
å·¥å…·åŒ…è£ï¼šä½¿ç”¨ AI SDK çš„ tool() helper
2. æ¶æ§‹å¤§å¹…ç°¡åŒ–
åˆªé™¤è‡ªå®šç¾©å·¥å…·ä»‹é¢ï¼šæ¸›å°‘ 90% çš„é¡å‹å®šç¾©
çµ±ä¸€å·¥å…·ç®¡ç†ï¼šæ‰€æœ‰å·¥å…·éƒ½æ˜¯ AI SDK æ ¼å¼
æ¸›å°‘åŒ…è£å±¤ï¼šç›´æ¥æ“ä½œ AI SDK åŸç”Ÿé¡å‹
3. æ¥­å‹™é‚è¼¯ä¿ç•™
ç¢ºèªæ©Ÿåˆ¶ï¼šé€šéå·¥å…·åŒ…è£å¯¦ç¾
åˆ†é¡ç®¡ç†ï¼šé€šéå…ƒæ•¸æ“šå¯¦ç¾
å¥åº·ç›£æ§ï¼šç°¡åŒ–ä½†ä¿ç•™æ ¸å¿ƒåŠŸèƒ½
4. æœªä¾†å…¼å®¹æ€§
AI SDK æ›´æ–°è‡ªå‹•å—ç›Šï¼šæ–°åŠŸèƒ½è‡ªå‹•å¯ç”¨
MCP æ¨™æº–æ”¯æ´ï¼šèˆ‡ AI SDK çš„ MCP å¯¦ç¾åŒæ­¥
å·¥å…·ç”Ÿæ…‹ç³»çµ±ï¼šå¯ç›´æ¥ä½¿ç”¨ AI SDK å·¥å…·åº«
é€™å€‹é‡æ§‹å°‡ ToolRegistry å¾ä¸€å€‹è¤‡é›œçš„å·¥å…·ç®¡ç†ç³»çµ±ç°¡åŒ–ç‚º AI SDK çš„è–„æ¥­å‹™åŒ…è£å±¤ï¼Œå¤§å¹…æ¸›å°‘ç¶­è­·è² æ“”åŒæ™‚æå‡èˆ‡ AI SDK çš„æ•´åˆåº¦ã€‚




Retry
const result = streamText({ model: this.model, messages: this.getModelMessages(), tools, // âŒ ç›´æ¥ä½¿ç”¨ï¼Œç„¡éœ€è½‰æ› });

å¦‚æœæ˜¯ç›´æ¥çµ¦äºˆ tools ï¼Œai sdk æœƒè‡ªå·±ä¸»å‹•åŸ·è¡Œï¼Ÿ

Edit

Analyzed AI SDK tool execution mechanism and constraints.
6s







éå¸¸å¥½çš„å•é¡Œï¼ä½ èªªå¾—å°ï¼Œé€™æ˜¯è¨­è¨ˆä¸­çš„é—œéµå•é¡Œã€‚

AI SDK çš„å·¥å…·åŸ·è¡Œè¡Œç‚º
å¦‚æœç›´æ¥å‚³ tools çµ¦ streamText()ï¼ŒAI SDK æœƒè‡ªå‹•åŸ·è¡Œå·¥å…·ï¼Œç•¶ï¼š

å·¥å…·å®šç¾©äº† execute å‡½æ•¸
LLM æ±ºå®šå‘¼å«è©²å·¥å…·æ™‚
typescript
const result = streamText({
  model: this.model,
  messages: this.getModelMessages(),
  tools: {
    myTool: tool({
      description: "...",
      inputSchema: z.object({...}),
      execute: async (input) => {
        // âŒ é€™æœƒè¢« AI SDK è‡ªå‹•åŸ·è¡Œï¼
        return "result";
      }
    })
  }
});
ä½†æˆ‘å€‘éœ€è¦æ‰¹æ¬¡ç¢ºèªæ©Ÿåˆ¶ï¼
æˆ‘å€‘çš„è¨­è¨ˆè¦æ±‚ï¼š

æ‰¹æ¬¡ç¢ºèªï¼šæ‰€æœ‰å·¥å…·éƒ½ç¢ºèªå¾Œæ‰åŸ·è¡Œ
ç”¨æˆ¶ç¢ºèªï¼šå±éšªå·¥å…·éœ€è¦ç¢ºèª
æ‰€ä»¥éœ€è¦é‡æ–°è¨­è¨ˆå·¥å…·åŸ·è¡Œæµç¨‹ã€‚

é‡æ–°è¨­è¨ˆæ–¹æ¡ˆ
A. åˆ†é›¢å·¥å…·å®šç¾©èˆ‡å·¥å…·åŸ·è¡Œ
typescript
// âœ… åªæä¾› schemaï¼Œä¸æä¾› execute
function createToolSchema<T extends Tool<any, any>>(tool: T) {
  return tool({
    description: tool.description,
    inputSchema: tool.inputSchema,
    // âŒ æ•…æ„ä¸æä¾› execute - è®“ AI SDK åªç”Ÿæˆ tool call
  });
}

export class ToolRegistry {
  // âœ… åˆ†é›¢ï¼šå·¥å…· schema vs å·¥å…·åŸ·è¡Œå™¨
  private toolSchemas: ToolSet = {};           // çµ¦ AI SDK ç”¨ï¼ˆç„¡ executeï¼‰
  private toolExecutors: Map<string, Tool<any, any>> = new Map();  // å¯¦éš›åŸ·è¡Œ
  
  registerTool(tool: Tool<any, any>) {
    const toolName = this.extractToolName(tool);
    
    // âœ… è¨»å†Š schemaï¼ˆç„¡åŸ·è¡Œå‡½æ•¸ï¼‰
    this.toolSchemas[toolName] = this.createToolSchema(tool);
    
    // âœ… å–®ç¨ä¿å­˜åŸ·è¡Œå™¨
    this.toolExecutors.set(toolName, tool);
  }
  
  // âœ… çµ¦ ChatSession ç”¨çš„ schemas
  getToolSchemas(): ToolSet {
    return this.toolSchemas;
  }
  
  // âœ… çµ¦ ToolCallRunner ç”¨çš„åŸ·è¡Œå™¨
  getToolExecutor(name: string): Tool<any, any> | undefined {
    return this.toolExecutors.get(name);
  }
}
B. ChatSession çš„å·¥å…·æµç¨‹æ§åˆ¶
typescript
// chat-session.ts
export class ChatSession<TOOLS extends ToolSet> {
  async runTurn(input: TurnInput) {
    // âœ… åªå‚³ schemasï¼ŒAI SDK ä¸æœƒè‡ªå‹•åŸ·è¡Œ
    const toolSchemas = this.toolRegistry.getToolSchemas() as TOOLS;
    
    const result = streamText({
      model: this.model,
      messages: this.getModelMessages(),
      tools: toolSchemas,  // âœ… åªæœ‰ schemaï¼Œç„¡ execute
    });
    
    // âœ… æ‰‹å‹•æ”¶é›† tool calls
    const toolCalls: ToolCallUnion<TOOLS>[] = [];
    for await (const part of result.fullStream) {
      if (part.type === "tool-call") {
        toolCalls.push(part);  // âœ… æ”¶é›†ä½†ä¸åŸ·è¡Œ
      }
    }
    
    if (toolCalls.length > 0) {
      // âœ… å§”è¨—çµ¦ ToolCallRunner è™•ç†ç¢ºèª + åŸ·è¡Œ
      const executionResult = await this.toolCallRunner.execute(
        toolCalls,
        this.toolCallConfirmations,
        this.toolAlwaysAllowRules,
        { chatId: this.id }
      );
      
      return executionResult;
    }
  }
}
C. ToolCallRunner è² è²¬å¯¦éš›åŸ·è¡Œ
typescript
// tool-call-runner.ts
export class ToolCallRunner<TOOLS extends ToolSet> {
  constructor(
    private toolRegistry: ToolRegistry,  // ç²å–åŸ·è¡Œå™¨
    private eventBus: IEventBus,
  ) {}
  
  private async executeScheduledTools(
    toolsWithStatus: ToolWithStatus<TOOLS>[],
  ): Promise<ToolExecutionResult<TOOLS>> {
    const executed: ToolResultUnion<TOOLS>[] = [];
    
    const scheduledTools = toolsWithStatus.filter(
      (t) => t.status === "scheduled",
    );

    await Promise.all(
      scheduledTools.map(async ({ toolCall }) => {
        // âœ… å¾ registry ç²å–å¯¦éš›åŸ·è¡Œå™¨
        const toolExecutor = this.toolRegistry.getToolExecutor(toolCall.toolName);
        if (!toolExecutor) {
          throw new Error(`Tool executor not found: ${toolCall.toolName}`);
        }
        
        // âœ… æ‰‹å‹•åŸ·è¡Œå·¥å…·
        const result = await toolExecutor.execute(toolCall.input);

        executed.push({
          type: "tool-result",
          toolCallId: toolCall.toolCallId,
          toolName: toolCall.toolName,
          input: toolCall.input,
          output: result,
        });
      }),
    );

    return {
      status: "completed",
      executed,
    };
  }
}
æ›¿ä»£æ–¹æ¡ˆï¼šä½¿ç”¨ stopWhen
å¦ä¸€å€‹é¸æ“‡æ˜¯ä½¿ç”¨ AI SDK çš„ stopWhen æ©Ÿåˆ¶ï¼š

typescript
// æ›¿ä»£æ–¹æ¡ˆï¼šæ§åˆ¶åŸ·è¡Œæµç¨‹
const result = streamText({
  model: this.model,
  messages: this.getModelMessages(),
  tools: this.toolRegistry.getToolSet(),
  stopWhen: (reason) => {
    // âœ… ç•¶æœ‰ tool calls æ™‚åœæ­¢ï¼Œä¸è‡ªå‹•åŸ·è¡Œ
    return reason === 'tool-calls';
  }
});

// ç„¶å¾Œæ‰‹å‹•è™•ç† tool calls
const toolCalls = result.toolCalls;
// é€åˆ° ToolCallRunner è™•ç†ç¢ºèªé‚è¼¯...
æ¨è–¦æ–¹æ¡ˆ
æ¨è–¦ä½¿ç”¨æ–¹æ¡ˆ Aï¼ˆåˆ†é›¢ schema èˆ‡åŸ·è¡Œï¼‰ï¼Œå› ç‚ºï¼š

æ§åˆ¶åº¦æœ€é«˜ï¼šå®Œå…¨æ§åˆ¶ä½•æ™‚åŸ·è¡Œå·¥å…·
ç¢ºèªæ©Ÿåˆ¶å®Œæ•´ï¼šå¯ä»¥å¯¦ç¾æ‰¹æ¬¡ç¢ºèª
èˆ‡ AI SDK å…¼å®¹ï¼šä¾ç„¶ä½¿ç”¨åŸç”Ÿé¡å‹
è²¬ä»»åˆ†é›¢æ¸…æ™°ï¼š
Registryï¼šç®¡ç†å·¥å…·å®šç¾©
ChatSessionï¼šè™•ç†å°è©±æµç¨‹
ToolCallRunnerï¼šè™•ç†å·¥å…·åŸ·è¡Œ
é€™æ¨£æ—¢ä¿æŒäº†èˆ‡ AI SDK çš„æœ€å¤§å…¼å®¹æ€§ï¼Œåˆå¯¦ç¾äº†æˆ‘å€‘éœ€è¦çš„æ‰¹æ¬¡ç¢ºèªæ©Ÿåˆ¶ã€‚




Retry
Run tool æ˜¯äº¤çµ¦ ToolCallRunnerï¼Œä¸æ˜¯ ChatSessionï¼Œè«‹åƒè€ƒ thread-tool_call_1_2.txt
è·Ÿ ai sdk åŸç”Ÿ tool ç›¸æ¯”ï¼Œæˆ‘å€‘çš„ tool å¤šäº†ä¸€å€‹ const needsConfirmation = await tool.shouldConfirmExecute?.(toolCall.input)ï¼Œå¯ä»¥æ€æ¨£è¨­è¨ˆé€™å€‹æ“´å±•çš„ toolï¼Ÿç›´æ¥ extends ai sdk Tool classï¼Ÿé‚„æ˜¯å®Œå…¨ä¸ä¾è³´æ¯”è¼ƒå¥½ï¼Ÿ
æˆ‘åœ¨æƒ³ scopeï¼Œä½ çš„æ„è¦‹ï¼Ÿ Global: single toolRegistry, initialize at startup given by the userSettings
toollRegistry Chat session: setup a session with a new toolSet, which is derived from the registry with the selected tools (or default) for this session
chatSession.toolSet
chatSession.toolCallRunner
Edit

Analyzed tool execution, design, and scope for AI system.
10s




ä½ èªªå¾—éå¸¸å°ï¼è®“æˆ‘åŸºæ–¼é€™äº›æ¾„æ¸…é‡æ–°è¨­è¨ˆï¼š

1. åŸ·è¡Œè²¬ä»»æ­¸å±¬ä¿®æ­£
ä½ èªªå¾—å°ï¼Œæ ¹æ“š thread-tool_call_1_2.txtï¼š

typescript
// âœ… æ­£ç¢ºçš„è²¬ä»»åˆ†å·¥
ChatSession: æ”¶é›† tool calls + å§”è¨—
ToolCallRunner: ç¢ºèªé‚è¼¯ + å¯¦éš›åŸ·è¡Œ
2. Tool æ“´å±•è¨­è¨ˆç­–ç•¥
A. çµ„åˆæ¨¡å¼ - æ¨è–¦æ–¹æ¡ˆ
typescript
// âœ… åŒ…è£ AI SDK Toolï¼Œæ·»åŠ ç¢ºèªé‚è¼¯
import type { Tool as AISDKTool } from 'ai';

export interface ExtendedTool<INPUT = any, OUTPUT = any> {
  // âœ… çµ„åˆ AI SDK åŸç”Ÿ tool
  aiTool: AISDKTool<INPUT, OUTPUT>;
  
  // âœ… æˆ‘å€‘çš„æ“´å±•æ–¹æ³•
  shouldConfirmExecute?(
    input: INPUT,
    signal?: AbortSignal
  ): Promise<ToolConfirmationDetails | null>;
  
  // âœ… æ–¹ä¾¿è¨ªå•çš„ä»£ç†å±¬æ€§
  get name(): string;
  get description(): string;
  get inputSchema(): any;
}

// âœ… å¯¦ç¾çµ„åˆåŒ…è£
export class ExtendedToolImpl<INPUT, OUTPUT> implements ExtendedTool<INPUT, OUTPUT> {
  constructor(
    public readonly aiTool: AISDKTool<INPUT, OUTPUT>,
    private confirmationLogic?: (input: INPUT) => Promise<ToolConfirmationDetails | null>
  ) {}

  // âœ… ä»£ç†åˆ° AI SDK tool
  get name(): string { return this.aiTool.name || 'unknown'; }
  get description(): string { return this.aiTool.description || ''; }
  get inputSchema(): any { return this.aiTool.inputSchema; }

  // âœ… æˆ‘å€‘çš„ç¢ºèªé‚è¼¯
  async shouldConfirmExecute(
    input: INPUT,
    signal?: AbortSignal
  ): Promise<ToolConfirmationDetails | null> {
    return this.confirmationLogic ? await this.confirmationLogic(input) : null;
  }

  // âœ… åŸ·è¡Œæ™‚ç›´æ¥èª¿ç”¨ AI SDK tool
  async execute(input: INPUT, options?: any): Promise<OUTPUT> {
    return await this.aiTool.execute(input, options);
  }
}
B. å·¥å…·å‰µå»º Helper
typescript
// âœ… ä¾¿åˆ©çš„å·¥å…·å‰µå»ºå‡½æ•¸
export function createExtendedTool<INPUT, OUTPUT>(
  aiTool: AISDKTool<INPUT, OUTPUT>,
  options?: {
    confirmationLogic?: (input: INPUT) => Promise<ToolConfirmationDetails | null>;
    dangerLevel?: 'low' | 'medium' | 'high';
  }
): ExtendedTool<INPUT, OUTPUT> {
  return new ExtendedToolImpl(
    aiTool,
    options?.confirmationLogic || (options?.dangerLevel ? 
      (input) => createDefaultConfirmation(aiTool.name, input, options.dangerLevel!) : 
      undefined
    )
  );
}
3. Scope è¨­è¨ˆæ¶æ§‹
A. Global ToolRegistry
typescript
// âœ… å…¨å±€å·¥å…·è¨»å†Šä¸­å¿ƒ
export class GlobalToolRegistry {
  private registeredTools: Map<string, ExtendedTool> = new Map();
  private mcpClients: Map<string, MCPClient> = new Map();
  
  constructor(
    private eventBus: IEventBus,
    private logger: Logger<ILogObj>
  ) {}

  // âœ… è¨»å†Šæ“´å±•å·¥å…·
  registerTool(tool: ExtendedTool, metadata?: ToolRegistrationMetadata): void {
    this.registeredTools.set(tool.name, tool);
    
    this.eventBus.emit({
      kind: "TOOL_REGISTERED",
      toolName: tool.name,
      timestamp: new Date(),
    });
  }

  // âœ… å¾ AI SDK tool å‰µå»ºä¸¦è¨»å†Š
  registerAITool<INPUT, OUTPUT>(
    aiTool: AISDKTool<INPUT, OUTPUT>,
    options?: {
      confirmationLogic?: (input: INPUT) => Promise<ToolConfirmationDetails | null>;
      dangerLevel?: 'low' | 'medium' | 'high';
      metadata?: ToolRegistrationMetadata;
    }
  ): void {
    const extendedTool = createExtendedTool(aiTool, options);
    this.registerTool(extendedTool, options?.metadata);
  }

  // âœ… è¨»å†Š MCP æœå‹™å™¨
  async registerMCPServer(serverConfig: MCPServerConfig): Promise<void> {
    const mcpClient = await createMCPClient({
      transport: { type: 'sse', url: serverConfig.url }
    });

    // âœ… ç²å– AI SDK æ ¼å¼çš„å·¥å…·
    const mcpTools = await mcpClient.tools();
    
    // âœ… åŒ…è£æˆ ExtendedTool
    Object.entries(mcpTools).forEach(([toolName, aiTool]) => {
      const extendedTool = createExtendedTool(aiTool, {
        // MCP å·¥å…·é»˜èªéœ€è¦ç¢ºèª
        dangerLevel: 'medium'
      });
      
      this.registerTool(extendedTool, {
        category: 'mcp',
        source: 'mcp',
        serverName: serverConfig.name
      });
    });

    this.mcpClients.set(serverConfig.name, mcpClient);
  }

  // âœ… ç²å–æ‰€æœ‰å¯ç”¨å·¥å…·
  getAllTools(): Map<string, ExtendedTool> {
    return new Map(this.registeredTools);
  }

  // âœ… æŒ‰é¡åˆ¥ç²å–å·¥å…·
  getToolsByCategory(category: string): ExtendedTool[] {
    // åŸºæ–¼ metadata éæ¿¾
    return Array.from(this.registeredTools.values()).filter(
      tool => this.getToolMetadata(tool.name)?.category === category
    );
  }
}
B. Session-Specific ToolSet
typescript
// âœ… Session ç´šåˆ¥çš„å·¥å…·é›†
export class SessionToolSet<TOOLS extends ToolSet> {
  private toolSchemas: TOOLS;           // çµ¦ AI SDK ç”¨
  private extendedTools: Map<string, ExtendedTool>;  // å¯¦éš›åŸ·è¡Œç”¨

  constructor(
    selectedTools: ExtendedTool[],
    private globalRegistry: GlobalToolRegistry
  ) {
    this.extendedTools = new Map();
    this.toolSchemas = {} as TOOLS;

    // âœ… æ§‹å»º session å·¥å…·é›†
    selectedTools.forEach(extendedTool => {
      // âœ… ä¿å­˜æ“´å±•å·¥å…·ï¼ˆç”¨æ–¼åŸ·è¡Œï¼‰
      this.extendedTools.set(extendedTool.name, extendedTool);
      
      // âœ… æå– AI SDK schemaï¼ˆç”¨æ–¼ LLMï¼‰
      this.toolSchemas[extendedTool.name as keyof TOOLS] = {
        description: extendedTool.description,
        inputSchema: extendedTool.inputSchema,
        // âŒ æ•…æ„ä¸æä¾› execute - æ‰‹å‹•æ§åˆ¶åŸ·è¡Œ
      } as TOOLS[keyof TOOLS];
    });
  }

  // âœ… çµ¦ streamText ç”¨çš„ schemas
  getToolSchemas(): TOOLS {
    return this.toolSchemas;
  }

  // âœ… çµ¦ ToolCallRunner ç”¨çš„åŸ·è¡Œå™¨
  getExtendedTool(name: string): ExtendedTool | undefined {
    return this.extendedTools.get(name);
  }

  // âœ… ç²å–æ‰€æœ‰å·¥å…·åç¨±
  getToolNames(): string[] {
    return Array.from(this.extendedTools.keys());
  }
}
C. ChatSession æ•´åˆ
typescript
// âœ… ChatSession ä½¿ç”¨ SessionToolSet
export class ChatSession<TOOLS extends ToolSet> {
  public readonly toolSet: SessionToolSet<TOOLS>;
  public readonly toolCallRunner: ToolCallRunner<TOOLS>;
  
  constructor(
    private globalRegistry: GlobalToolRegistry,
    sessionConfig: {
      selectedTools?: string[];  // å·¥å…·åç¨±åˆ—è¡¨
      toolCategories?: string[]; // æˆ–æŒ‰é¡åˆ¥é¸æ“‡
    }
  ) {
    // âœ… å¾ global registry é¸æ“‡å·¥å…·
    const selectedTools = this.selectSessionTools(sessionConfig);
    
    // âœ… å‰µå»º session å·¥å…·é›†
    this.toolSet = new SessionToolSet(selectedTools, globalRegistry);
    
    // âœ… å‰µå»º runner
    this.toolCallRunner = new ToolCallRunner(this.toolSet, this.eventBus);
  }

  private selectSessionTools(config: any): ExtendedTool[] {
    if (config.selectedTools) {
      return config.selectedTools
        .map(name => this.globalRegistry.getAllTools().get(name))
        .filter(Boolean) as ExtendedTool[];
    }
    
    if (config.toolCategories) {
      return config.toolCategories
        .flatMap(category => this.globalRegistry.getToolsByCategory(category));
    }
    
    // é»˜èªï¼šæ‰€æœ‰å·¥å…·
    return Array.from(this.globalRegistry.getAllTools().values());
  }

  async runTurn(input: TurnInput): Promise<ConversationResult> {
    // âœ… ä½¿ç”¨ session å·¥å…·é›†çš„ schemas
    const result = streamText({
      model: this.model,
      messages: this.getModelMessages(),
      tools: this.toolSet.getToolSchemas(),  // âŒ åªæœ‰ schema
    });

    // âœ… æ”¶é›† tool callsï¼Œå§”è¨—çµ¦ runner
    const toolCalls: ToolCallUnion<TOOLS>[] = [];
    for await (const part of result.fullStream) {
      if (part.type === "tool-call") {
        toolCalls.push(part);
      }
    }

    if (toolCalls.length > 0) {
      // âœ… å§”è¨—çµ¦ ToolCallRunner
      return await this.toolCallRunner.execute(
        toolCalls,
        this.toolCallConfirmations,
        this.toolAlwaysAllowRules,
        { chatId: this.id }
      );
    }
  }
}
D. ToolCallRunner æ›´æ–°
typescript
export class ToolCallRunner<TOOLS extends ToolSet> {
  constructor(
    private sessionToolSet: SessionToolSet<TOOLS>,  // âœ… ä½¿ç”¨ session å·¥å…·é›†
    private eventBus: IEventBus,
  ) {}

  private async initializeToolStatuses(
    toolCalls: ToolCallUnion<TOOLS>[],
    confirmations: ToolCallConfirmation[],
    alwaysAllowRules: ToolAlwaysAllowRule[],
  ): Promise<ToolWithStatus<TOOLS>[]> {
    return Promise.all(
      toolCalls.map(async (toolCall) => {
        // ... ç¢ºèªé‚è¼¯ ...

        // âœ… æª¢æŸ¥æ˜¯å¦éœ€è¦ç¢ºèª
        const extendedTool = this.sessionToolSet.getExtendedTool(toolCall.toolName);
        const needsConfirmation = await extendedTool?.shouldConfirmExecute?.(
          toolCall.input
        );
        
        return {
          toolCall,
          status: needsConfirmation ? "awaiting_approval" : "scheduled",
        };
      }),
    );
  }

  private async executeScheduledTools(
    toolsWithStatus: ToolWithStatus<TOOLS>[],
  ): Promise<ToolExecutionResult<TOOLS>> {
    // ... åŸ·è¡Œé‚è¼¯ ...
    
    await Promise.all(
      scheduledTools.map(async ({ toolCall }) => {
        // âœ… ç²å–æ“´å±•å·¥å…·ä¸¦åŸ·è¡Œ
        const extendedTool = this.sessionToolSet.getExtendedTool(toolCall.toolName);
        const result = await extendedTool?.execute(toolCall.input);
        // ...
      }),
    );
  }
}
ç¸½çµå„ªå‹¢
æ¸…æ™°çš„ Scope åˆ†é›¢ï¼š
Global Registryï¼šæ‰€æœ‰å·¥å…·çš„ä¸­å¤®ç®¡ç†
Session ToolSetï¼šæ¯å€‹æœƒè©±çš„å·¥å…·é¸æ“‡
ToolCallRunnerï¼šå·¥å…·åŸ·è¡Œé‚è¼¯
AI SDK æœ€å¤§åŒ–åˆ©ç”¨ï¼š
çµ„åˆæ¨¡å¼ä¿æŒèˆ‡ AI SDK Tool çš„å…¼å®¹
ç›´æ¥ä½¿ç”¨ AI SDK çš„ MCP æ”¯æŒ
ä¿æŒé¡å‹å®‰å…¨å’Œæœªä¾†å…¼å®¹æ€§
éˆæ´»çš„å·¥å…·ç®¡ç†ï¼š
æ”¯æŒæŒ‰éœ€é¸æ“‡å·¥å…·
æ”¯æŒå·¥å…·åˆ†é¡
æ”¯æŒæœƒè©±ç´šåˆ¥çš„å·¥å…·é…ç½®
è²¬ä»»åˆ†é›¢æ¸…æ™°ï¼š
Registryï¼šå·¥å…·è¨»å†Šå’Œç®¡ç†
ToolSetï¼šå·¥å…·é¸æ“‡å’Œçµ„ç¹”
Runnerï¼šå·¥å…·åŸ·è¡Œå’Œç¢ºèªé‚è¼¯
é€™å€‹è¨­è¨ˆæ—¢ä¿æŒäº†èˆ‡ AI SDK çš„æœ€å¤§å…¼å®¹æ€§ï¼Œåˆæä¾›äº†æˆ‘å€‘éœ€è¦çš„ç¢ºèªæ©Ÿåˆ¶å’Œéˆæ´»çš„å·¥å…·ç®¡ç†ã€‚




Retry
çµ„åˆæ¨¡å¼okay 
export interface ExtendedTool<INPUT = any, OUTPUT = any> {  
// âœ… æ–¹ä¾¿è¨ªå•çš„ä»£ç†å±¬æ€§
>>> ä¸éœ€è¦ï¼Œæˆ‘å€‘å¯ä»¥ç›´æ¥ä½¿ç”¨ `aiTool.name, ... å–å¾—`
get name(): string;
get description(): string;
get inputSchema(): any;
}
ä¸éœ€è¦ å·¥å…·å‰µå»º Helper
registerAITool -> ä¸éœ€è¦
Mcp -> è¦ç”¨ ai sdk mcp toolsï¼Œè¦çµ¦ import
ä¸éœ€è¦ class SessionToolSet ï¼Œç›´æ¥ä½¿ç”¨ native ToolSet
ChatSession å¯èƒ½ä¹Ÿä¸éœ€è¦å­˜ toolSetï¼Ÿ ``` // In ChatSession constructor(toolRegistry, toolNames?: string[], ) { toolSet = toolRegistry.getToolSet(toolNames) }
// In ToolCallRunner
const extendedTool = this.toolRegistry.getExtendedTool(toolCall.toolName);  // return extended tool
extendedTool.tool.execute(â€¦)
``
6. extendedTool.tool.execute(â€¦)` æ„Ÿè¦ºä¸å¤ªå¥½ï¼Œextended tool é‚„å¯ä»¥å«ä»€éº¼ï¼Ÿ

è«‹åˆ†æè¨è«–

Edit



Refined design strategy to simplify AI tool architecture.
7s




ä½ çš„ç°¡åŒ–å»ºè­°éå¸¸å¥½ï¼è®“æˆ‘é‡æ–°è¨­è¨ˆä¸€å€‹æ›´ç°¡æ½”çš„ç‰ˆæœ¬ï¼š

1. ç°¡åŒ–çš„ ExtendedTool è¨­è¨ˆ
typescript
// âœ… æ¥µç°¡çš„çµ„åˆè¨­è¨ˆ
export interface ExtendedTool<INPUT = any, OUTPUT = any> {
  aiTool: AISDKTool<INPUT, OUTPUT>;  // âœ… ç›´æ¥æš´éœ²ï¼Œç”¨ aiTool.name è¨ªå•
  
  shouldConfirmExecute?(
    input: INPUT,
    signal?: AbortSignal
  ): Promise<ToolConfirmationDetails | null>;
}

// âœ… ç°¡å–®çš„å¯¦ç¾é¡
export class ExtendedToolImpl<INPUT, OUTPUT> implements ExtendedTool<INPUT, OUTPUT> {
  constructor(
    public readonly aiTool: AISDKTool<INPUT, OUTPUT>,
    private confirmationLogic?: (input: INPUT) => Promise<ToolConfirmationDetails | null>
  ) {}

  async shouldConfirmExecute(
    input: INPUT,
    signal?: AbortSignal
  ): Promise<ToolConfirmationDetails | null> {
    return this.confirmationLogic ? await this.confirmationLogic(input) : null;
  }
}
2. ç°¡åŒ–çš„ GlobalToolRegistry
typescript
import { experimental_createMCPClient as createMCPClient } from 'ai';

export class GlobalToolRegistry {
  private extendedTools: Map<string, ExtendedTool> = new Map();
  private toolMetadata: Map<string, ToolRegistrationMetadata> = new Map();
  
  constructor(
    private eventBus: IEventBus,
    private logger: Logger<ILogObj>
  ) {}

  // âœ… ç›´æ¥è¨»å†Š ExtendedTool
  registerTool(extendedTool: ExtendedTool, metadata?: ToolRegistrationMetadata): void {
    const toolName = extendedTool.aiTool.name || 'unknown';
    this.extendedTools.set(toolName, extendedTool);
    this.toolMetadata.set(toolName, {
      category: 'built-in',
      source: 'built-in',
      registeredAt: new Date(),
      ...metadata
    });
  }

  // âœ… ä½¿ç”¨ AI SDK MCP
  async registerMCPServer(serverConfig: MCPServerConfig): Promise<void> {
    const mcpClient = await createMCPClient({
      transport: {
        type: 'sse',
        url: serverConfig.url,
        headers: serverConfig.oauth?.enabled ? {
          Authorization: `Bearer ${await this.getOAuthToken(serverConfig)}`
        } : undefined
      }
    });

    // âœ… ç²å– AI SDK åŸç”Ÿ MCP tools
    const mcpTools = await mcpClient.tools();
    
    // âœ… åŒ…è£æˆ ExtendedTool
    Object.entries(mcpTools).forEach(([toolName, aiTool]) => {
      const extendedTool = new ExtendedToolImpl(
        aiTool,
        // MCP å·¥å…·é è¨­éœ€è¦ç¢ºèª
        async (input) => ({
          message: `Execute MCP tool: ${toolName}`,
          dangerLevel: 'medium' as const,
          affectedResources: []
        })
      );
      
      this.registerTool(extendedTool, {
        category: 'mcp',
        source: 'mcp',
        serverName: serverConfig.name
      });
    });
  }

  // âœ… æ ¹æ“šå·¥å…·åç¨±ç²å– ToolSetï¼ˆçµ¦ ChatSession ç”¨ï¼‰
  getToolSet(toolNames?: string[]): ToolSet {
    const toolSet: ToolSet = {};
    
    const selectedNames = toolNames || Array.from(this.extendedTools.keys());
    
    selectedNames.forEach(name => {
      const extendedTool = this.extendedTools.get(name);
      if (extendedTool) {
        // âœ… åªæä¾› schemaï¼Œä¸æä¾› execute
        toolSet[name] = {
          description: extendedTool.aiTool.description,
          inputSchema: extendedTool.aiTool.inputSchema,
          // âŒ æ•…æ„ä¸æä¾› execute
        };
      }
    });
    
    return toolSet;
  }

  // âœ… ç²å– ExtendedToolï¼ˆçµ¦ ToolCallRunner ç”¨ï¼‰
  getExtendedTool(name: string): ExtendedTool | undefined {
    return this.extendedTools.get(name);
  }
}
3. ç°¡åŒ–çš„ ChatSession
typescript
export class ChatSession<TOOLS extends ToolSet> {
  public readonly toolCallRunner: ToolCallRunner<TOOLS>;
  
  constructor(
    private toolRegistry: GlobalToolRegistry,
    toolNames?: string[],  // âœ… é¸æ“‡çš„å·¥å…·åç¨±
    // ... å…¶ä»–åƒæ•¸
  ) {
    // âœ… å‰µå»º runnerï¼Œå‚³å…¥ registry
    this.toolCallRunner = new ToolCallRunner(this.toolRegistry, this.eventBus);
  }

  async runTurn(input: TurnInput): Promise<ConversationResult> {
    // âœ… å‹•æ…‹ç²å– ToolSet
    const toolSet = this.toolRegistry.getToolSet(this.selectedToolNames) as TOOLS;
    
    const result = streamText({
      model: this.model,
      messages: this.getModelMessages(),
      tools: toolSet,  // âœ… åªæœ‰ schemaï¼Œç„¡ execute
    });

    // âœ… æ”¶é›† tool calls
    const toolCalls: ToolCallUnion<TOOLS>[] = [];
    for await (const part of result.fullStream) {
      if (part.type === "tool-call") {
        toolCalls.push(part);
      }
    }

    if (toolCalls.length > 0) {
      // âœ… å§”è¨—çµ¦ runner
      return await this.toolCallRunner.execute(
        toolCalls,
        this.toolCallConfirmations,
        this.toolAlwaysAllowRules,
        { chatId: this.id }
      );
    }
  }
}
4. ç°¡åŒ–çš„ ToolCallRunner
typescript
export class ToolCallRunner<TOOLS extends ToolSet> {
  constructor(
    private toolRegistry: GlobalToolRegistry,  // âœ… ç›´æ¥ä½¿ç”¨ registry
    private eventBus: IEventBus,
  ) {}

  private async initializeToolStatuses(
    toolCalls: ToolCallUnion<TOOLS>[],
    confirmations: ToolCallConfirmation[],
    alwaysAllowRules: ToolAlwaysAllowRule[],
  ): Promise<ToolWithStatus<TOOLS>[]> {
    return Promise.all(
      toolCalls.map(async (toolCall) => {
        // ... ç¢ºèªæª¢æŸ¥é‚è¼¯ ...

        // âœ… æª¢æŸ¥æ˜¯å¦éœ€è¦ç¢ºèª
        const extendedTool = this.toolRegistry.getExtendedTool(toolCall.toolName);
        const needsConfirmation = await extendedTool?.shouldConfirmExecute?.(
          toolCall.input
        );
        
        return {
          toolCall,
          status: needsConfirmation ? "awaiting_approval" : "scheduled",
        };
      }),
    );
  }

  private async executeScheduledTools(
    toolsWithStatus: ToolWithStatus<TOOLS>[],
  ): Promise<ToolExecutionResult<TOOLS>> {
    const executed: ToolResultUnion<TOOLS>[] = [];
    const scheduledTools = toolsWithStatus.filter(t => t.status === "scheduled");

    await Promise.all(
      scheduledTools.map(async ({ toolCall }) => {
        const extendedTool = this.toolRegistry.getExtendedTool(toolCall.toolName);
        if (!extendedTool) {
          throw new Error(`Extended tool not found: ${toolCall.toolName}`);
        }
        
        // âœ… åŸ·è¡Œ AI SDK åŸç”Ÿå·¥å…·
        const result = await extendedTool.aiTool.execute(toolCall.input);

        executed.push({
          type: "tool-result",
          toolCallId: toolCall.toolCallId,
          toolName: toolCall.toolName,
          input: toolCall.input,
          output: result,
        });
      }),
    );

    return {
      status: "completed",
      executed,
    };
  }
}
5. é—œæ–¼å‘½åçš„è¨è«–
ä½ èªª extendedTool.tool.execute(...) æ„Ÿè¦ºä¸å¥½ï¼Œç¢ºå¯¦å¦‚æ­¤ã€‚å¹¾å€‹é¸é …ï¼š

é¸é … Aï¼šaiToolï¼ˆæ¨è–¦ï¼‰
typescript
const result = await extendedTool.aiTool.execute(toolCall.input);
âœ… æ¸…æ¥šè¡¨æ˜é€™æ˜¯ AI SDK çš„åŸç”Ÿå·¥å…·

é¸é … Bï¼šnativeTool
typescript
const result = await extendedTool.nativeTool.execute(toolCall.input);
âœ… å¼·èª¿æ˜¯åŸç”Ÿå·¥å…·

é¸é … Cï¼šbaseTool
typescript
const result = await extendedTool.baseTool.execute(toolCall.input);
âœ… è¡¨æ˜æ˜¯åŸºç¤å·¥å…·

é¸é … Dï¼šç›´æ¥åœ¨ ExtendedTool ä¸Šä»£ç† execute
typescript
export class ExtendedToolImpl<INPUT, OUTPUT> implements ExtendedTool<INPUT, OUTPUT> {
  // âœ… ä»£ç†åŸ·è¡Œæ–¹æ³•
  async execute(input: INPUT, options?: any): Promise<OUTPUT> {
    return await this.aiTool.execute(input, options);
  }
}

// ä½¿ç”¨æ™‚ï¼š
const result = await extendedTool.execute(toolCall.input);
æ¨è–¦é¸é … A (aiTool)ï¼Œå› ç‚ºï¼š

æ˜ç¢ºè¡¨æ˜æ˜¯ AI SDK åŸç”Ÿå·¥å…·
èˆ‡æˆ‘å€‘çš„è¨­è¨ˆæ„åœ–ä¸€è‡´ï¼ˆçµ„åˆä¸æ˜¯ç¹¼æ‰¿ï¼‰
ä¸æœƒé€ æˆæ··æ·†
ç¸½çµ
é€™å€‹ç°¡åŒ–ç‰ˆæœ¬ï¼š

âœ… ç§»é™¤äº†ä¸å¿…è¦çš„ä»£ç†å±¬æ€§å’Œ helper å‡½æ•¸
âœ… ç›´æ¥ä½¿ç”¨ AI SDK çš„ MCP æ”¯æŒ
âœ… ä½¿ç”¨åŸç”Ÿ ToolSet è€Œä¸æ˜¯è‡ªå®šç¾©é¡
âœ… ChatSession ä¸å„²å­˜ toolSetï¼Œå‹•æ…‹ç²å–
âœ… æ¸…æ™°çš„åŸ·è¡Œè·¯å¾‘ï¼šextendedTool.aiTool.execute()
é€™æ¨£æ—¢ä¿æŒäº†èˆ‡ AI SDK çš„æœ€å¤§å…¼å®¹æ€§ï¼Œåˆå¤§å¹…ç°¡åŒ–äº†æ¶æ§‹è¤‡é›œåº¦ã€‚




Retry
æˆ‘æ˜¯æƒ³è¦æ”¹ ExtendedTool é€™å€‹åå­—ï¼Œæœ‰å»ºè­°å—ï¼Ÿ

Edit

æ¢ç´¢ä¸¦å»ºè­°å¤šå€‹å·¥å…·å‘½åæ–¹æ¡ˆï¼Œèšç„¦åŠŸèƒ½ç‰¹æ€§
21s






ç¢ºå¯¦ï¼ŒExtendedTool é€™å€‹åå­—ä¸å¤ªå¥½ã€‚è®“æˆ‘åˆ†æä¸€ä¸‹é€™å€‹é¡å‹çš„æ ¸å¿ƒç‰¹é»ä¾†æ‰¾æ›´å¥½çš„åå­—ï¼š

æ ¸å¿ƒç‰¹é»åˆ†æ
çµ„åˆ AI SDK åŸç”Ÿå·¥å…·
æ·»åŠ ç¢ºèªé‚è¼¯
æ¥­å‹™å±¤çš„å·¥å…·åŒ…è£
å‘½åå»ºè­°
é¸é … 1: ToolWrapper
typescript
export interface ToolWrapper<INPUT = any, OUTPUT = any> {
  aiTool: AISDKTool<INPUT, OUTPUT>;
  shouldConfirmExecute?(...): Promise<...>;
}

// ä½¿ç”¨ï¼š
const wrapper = this.toolRegistry.getToolWrapper(toolCall.toolName);
await wrapper.aiTool.execute(toolCall.input);
âœ… ç°¡æ½”æ˜äº†ï¼Œç›´æ¥è¡¨é”"åŒ…è£å™¨"çš„æ¦‚å¿µ âœ… é€šç”¨æ€§å¥½ï¼Œä¸é™å®šå…·é«”åŠŸèƒ½

é¸é … 2: ConfirmableTool
typescript
export interface ConfirmableTool<INPUT = any, OUTPUT = any> {
  aiTool: AISDKTool<INPUT, OUTPUT>;
  shouldConfirmExecute?(...): Promise<...>;
}

// ä½¿ç”¨ï¼š
const confirmableTool = this.toolRegistry.getConfirmableTool(toolCall.toolName);
await confirmableTool.aiTool.execute(toolCall.input);
âœ… çªå‡ºä¸»è¦åŠŸèƒ½ï¼Œå¼·èª¿"å¯ç¢ºèª"ç‰¹æ€§ âœ… èªç¾©æ¸…æ™°ï¼Œä¸€çœ‹å°±çŸ¥é“ç”¨é€”

é¸é … 3: ManagedTool
typescript
export interface ManagedTool<INPUT = any, OUTPUT = any> {
  aiTool: AISDKTool<INPUT, OUTPUT>;
  shouldConfirmExecute?(...): Promise<...>;
}

// ä½¿ç”¨ï¼š
const managedTool = this.toolRegistry.getManagedTool(toolCall.toolName);
await managedTool.aiTool.execute(toolCall.input);
âœ… è¡¨é”æ¥­å‹™ç®¡ç†ï¼Œè¡¨æ˜æ˜¯å—æ¥­å‹™é‚è¼¯ç®¡ç†çš„å·¥å…· âœ… æœªä¾†æ“´å±•æ€§ï¼Œå¯ä»¥æ·»åŠ æ›´å¤šç®¡ç†åŠŸèƒ½

é¸é … 4: BusinessTool
typescript
export interface BusinessTool<INPUT = any, OUTPUT = any> {
  aiTool: AISDKTool<INPUT, OUTPUT>;
  shouldConfirmExecute?(...): Promise<...>;
}

// ä½¿ç”¨ï¼š
const businessTool = this.toolRegistry.getBusinessTool(toolCall.toolName);
await businessTool.aiTool.execute(toolCall.input);
âœ… å±¤æ¬¡åˆ†æ˜ï¼Œæ¥­å‹™å±¤ vs æŠ€è¡“å±¤ï¼ˆAI SDKï¼‰ âœ… è·è²¬æ¸…æ™°ï¼ŒåŒ…å«æ¥­å‹™é‚è¼¯çš„å·¥å…·

é¸é … 5: GuardedTool
typescript
export interface GuardedTool<INPUT = any, OUTPUT = any> {
  aiTool: AISDKTool<INPUT, OUTPUT>;
  shouldConfirmExecute?(...): Promise<...>;
}

// ä½¿ç”¨ï¼š
const guardedTool = this.toolRegistry.getGuardedTool(toolCall.toolName);
await guardedTool.aiTool.execute(toolCall.input);
âœ… å®‰å…¨å°å‘ï¼Œå¼·èª¿"å—ä¿è­·"çš„ç‰¹æ€§ âœ… å½¢è±¡ç”Ÿå‹•ï¼Œå®¹æ˜“ç†è§£

æ¨è–¦æ’åº
ToolWrapper - æœ€ç›´æ¥ï¼Œé€šç”¨æ€§æœ€å¥½
ConfirmableTool - åŠŸèƒ½å°å‘ï¼Œèªç¾©æœ€æ¸…æ™°
ManagedTool - æ¥­å‹™å°å‘ï¼Œæ“´å±•æ€§å¥½
å°æ¯”ä½¿ç”¨å ´æ™¯
typescript
// æ–¹æ¡ˆ 1: ToolWrapper
const wrapper = registry.getToolWrapper(name);
const result = await wrapper.aiTool.execute(input);

// æ–¹æ¡ˆ 2: ConfirmableTool  
const confirmable = registry.getConfirmableTool(name);
const result = await confirmable.aiTool.execute(input);

// æ–¹æ¡ˆ 3: ManagedTool
const managed = registry.getManagedTool(name);
const result = await managed.aiTool.execute(input);
æˆ‘å€‹äººæ¨è–¦ ToolWrapperï¼Œå› ç‚ºï¼š

æœ€ç°¡æ½”ç›´è§€
ä¸éåº¦é™å®šåŠŸèƒ½ï¼ˆæœªä¾†å¯èƒ½æ·»åŠ å…¶ä»–åŒ…è£é‚è¼¯ï¼‰
èˆ‡ aiTool å½¢æˆå¾ˆå¥½çš„å°æ¯”ï¼šwrapper æ˜¯æˆ‘å€‘çš„ï¼ŒaiTool æ˜¯ AI SDK çš„
ä½ è¦ºå¾—å“ªå€‹æ¯”è¼ƒå¥½ï¼Ÿ

