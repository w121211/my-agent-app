
## Notes

ChatServiceå·²ç¶“å»¢æ£„ï¼Œå¾Œç«¯ chat ç³»çµ±é·ç§»è‡³ chat engine packages/events-core/src/services/chat-engine
ä¸ç”¨è€ƒæ…® backward compatibility
---

è®“æˆ‘å€‘ä¸€èµ·æª¢è¦– source code: packages/events-core/src/services/tool-call
ç´”è¨è«–ï¼Œä¸è¦ä¿®æ”¹

tool call system æ˜¯æ€æ¨£é‹ä½œï¼Ÿä»–çš„é‹ä½œæµç¨‹ï¼Ÿ
æœ‰æ”¯æ´mcpï¼Ÿå¦‚ä½•é‹ä½œï¼Ÿ
Tool call ç›¸é—œçš„ types æ‡‰è©²è¦ç›´æ¥å¾ ai.sdk importï¼Ÿ
ä½ è¦ºå¾—æ•´å€‹ tool call ç³»çµ±æœ‰å“ªäº›å•é¡Œï¼Ÿ
  private outputUpdateHandler?: OutputUpdateHandler;
  private onAllToolCallsComplete?: AllToolCallsCompleteHandler;
  private onToolCallsUpdate?: ToolCallsUpdateHandler;

æˆ‘è¦ºå¾—å¯ä»¥ä¸ç”¨ callbackï¼Œè€Œæ˜¯è·Ÿ chat-engine ä¸€æ¨£ï¼Œä»¥ event å‚³è¼¸ï¼Œä½ çš„çœ‹æ³•ï¼Ÿ

Edit

Analyzed tool-call system architecture, challenges, and potential improvements.
24s









è®“æˆ‘ä»”ç´°åˆ†æé€™å€‹ tool-call ç³»çµ±çš„æ¶æ§‹å’Œé‹ä½œæ–¹å¼ã€‚

Tool Call ç³»çµ±é‹ä½œæµç¨‹
å¾ ToolCallScheduler.execute() æ–¹æ³•ä¾†çœ‹ï¼Œæ•´å€‹æµç¨‹æ˜¯é€™æ¨£çš„ï¼š

1. åˆå§‹åŒ–èˆ‡é©—è­‰éšæ®µ
typescript
// 1. å‰µå»º ToolCall å°è±¡ï¼ˆvalidating ç‹€æ…‹ï¼‰
const newToolCalls: ToolCall[] = requestsToProcess.map(reqInfo => ({
  status: "validating",
  request: reqInfo,
  tool: toolRegistry.getTool(reqInfo.name),
  startTime: Date.now()
}))

// 2. è™•ç†æ¯å€‹å·¥å…·çš„é©—è­‰å’Œæ¬Šé™æª¢æŸ¥
for (const toolCall of newToolCalls) {
  await this.processToolCallValidation(toolCall, messageId, signal)
}
2. æ¬Šé™èˆ‡å®‰å…¨æª¢æŸ¥
typescript
// æ ¹æ“š approvalMode å’Œå·¥å…·å±éšªç­‰ç´šæ±ºå®šæµç¨‹
if (this.approvalMode === ApprovalMode.YOLO) {
  // è‡ªå‹•æ‰¹å‡†
  this.setStatusInternal(messageId, reqInfo.callId, "scheduled")
} else {
  // æª¢æŸ¥æ˜¯å¦éœ€è¦ç”¨æˆ¶ç¢ºèª
  const confirmationDetails = await toolInstance.shouldConfirmExecute(reqInfo.args)
  if (confirmationDetails) {
    // éœ€è¦ç¢ºèª -> awaiting_approval ç‹€æ…‹
    // ç™¼é€ TOOL_PERMISSION_REQUEST äº‹ä»¶
  } else {
    // ç›´æ¥èª¿åº¦åŸ·è¡Œ
    this.setStatusInternal(messageId, reqInfo.callId, "scheduled")
  }
}
3. ä¸¦è¡ŒåŸ·è¡Œéšæ®µ
typescript
// æ‰€æœ‰ scheduled ç‹€æ…‹çš„å·¥å…·ä¸¦è¡ŒåŸ·è¡Œ
await Promise.all(
  scheduledCalls.map(toolCall => 
    this.executeSingleToolCall(messageId, toolCall, signal)
  )
)
MCP æ”¯æ´æ¶æ§‹
MCP æ•´åˆé€é ToolRegistry.registerMCPServer() å¯¦ç¾ï¼š

è¨­è¨ˆæ¶æ§‹
typescript
// 1. è¨»å†Š MCP ä¼ºæœå™¨
await toolRegistry.registerMCPServer({
  name: "github-mcp",
  url: "http://localhost:3001",
  oauth: { enabled: true, clientId: "..." }
})

// 2. å‰µå»º MCP å·¥å…·åŒ…è£å™¨
const mcpTool = this.createMCPToolWrapper(toolInfo, mcpClient, serverConfig)

// 3. çµ±ä¸€ Tool ä»‹é¢
interface Tool {
  shouldConfirmExecute(): Promise<ToolCallConfirmationDetails | null>
  execute(args, options): Promise<unknown>
  getMetadata(): ToolMetadata
}
ç›®å‰å¯¦ç¾ç‹€æ³ï¼šMCP å®¢æˆ¶ç«¯æ˜¯ mock å¯¦ç¾ï¼Œä½†æ¶æ§‹å·²ç¶“æº–å‚™å¥½äº†çœŸå¯¦æ•´åˆã€‚

é—œæ–¼ AI SDK Types
ä½ æåˆ°çš„å¾ˆå°ï¼ç›®å‰ç³»çµ±è‡ªå®šç¾©äº†å¾ˆå¤šå¯èƒ½è·Ÿ AI SDK é‡ç–Šçš„é¡å‹ï¼š

typescript
// ç¾åœ¨çš„è‡ªå®šç¾©é¡å‹
export interface ToolCallRequestInfo {
  callId: string
  name: string  
  args: Record<string, unknown>
}

// æ‡‰è©²è€ƒæ…®ä½¿ç”¨ AI SDK æ¨™æº–é¡å‹
import { ToolCall, ToolInvocation, ToolResult } from 'ai'
è¨­è¨ˆå»ºè­°ï¼šæ‡‰è©²ç›¡é‡ä½¿ç”¨ AI SDK çš„æ¨™æº–é¡å‹ï¼Œåªåœ¨éœ€è¦é¡å¤–æ¬„ä½æ™‚æ‰æ“´å±•ã€‚é€™æ¨£èƒ½ç¢ºä¿èˆ‡ AI SDK v5 çš„äº’æ“ä½œæ€§ã€‚

ç³»çµ±è¨­è¨ˆå•é¡Œåˆ†æ
1. Callback vs Event æ¶æ§‹ä¸ä¸€è‡´
ä½ èªªå¾—å¾ˆå°ï¼ç¾åœ¨çš„ callback æ¶æ§‹å‰µé€ äº†ä¸å¿…è¦çš„è€¦åˆï¼š

typescript
// ç¾åœ¨çš„å•é¡Œ
private outputUpdateHandler?: OutputUpdateHandler
private onAllToolCallsComplete?: AllToolCallsCompleteHandler  
private onToolCallsUpdate?: ToolCallsUpdateHandler
ç‚ºä»€éº¼é€™æ˜¯å•é¡Œï¼š

èˆ‡ç³»çµ±å…¶ä»–éƒ¨åˆ†çš„ event-driven æ¶æ§‹ä¸ä¸€è‡´
å‰µé€ ç·Šè€¦åˆ - èª¿ç”¨è€…å¿…é ˆç›´æ¥å‚³å…¥ callback
é›£ä»¥æ“´å±• - æ–°çš„ç›£è½è€…éœ€è¦ä¿®æ”¹ scheduler æ§‹é€ å‡½æ•¸
æ›´å¥½çš„è¨­è¨ˆï¼šå®Œå…¨é€é EventBus é€šè¨Šï¼Œå°±åƒ chat-engine ä¸€æ¨£ï¼š

typescript
// æ”¹ç”¨ç´” event é©…å‹•
this.eventBus.emit({
  kind: "TOOL_OUTPUT_UPDATE",
  messageId,
  toolCallId,  
  outputChunk: chunk,
  timestamp: new Date()
})
2. è¤‡é›œçš„ç‹€æ…‹ç®¡ç†
7 ç¨®ç‹€æ…‹çš„ç‹€æ…‹æ©ŸåŠ ä¸Š setStatusInternal çš„è¤‡é›œé‚è¼¯ï¼š

typescript
// ç‹€æ…‹è½‰æ›é‚è¼¯å¾ˆè¤‡é›œ
switch (newStatus) {
  case "success": return { /* è¤‡é›œçš„ç‹€æ…‹å°è±¡æ§‹é€  */ }
  case "error": return { /* å¦ä¸€ç¨®æ§‹é€ é‚è¼¯ */ }
  // ... æ›´å¤šç‹€æ…‹è™•ç†
}
è¨­è¨ˆå»ºè­°ï¼šè€ƒæ…®ä½¿ç”¨æ›´ç°¡å–®çš„ç‹€æ…‹æ©Ÿæ¨¡å¼ï¼Œæˆ–å°‡ç‹€æ…‹è½‰æ›é‚è¼¯åˆ†é›¢åˆ°å°ˆé–€çš„ç‹€æ…‹ç®¡ç†å™¨ã€‚

3. æ¶æ§‹ä¸ä¸€è‡´æ€§
Chat Engineï¼šç´” event-drivenï¼Œæ¸…çˆ½çš„ session ç®¡ç†
Tool Callï¼šæ··åˆ callback + eventï¼Œè¤‡é›œçš„ç‹€æ…‹ç®¡ç†
çµ±ä¸€æ€§å»ºè­°ï¼šTool Call ç³»çµ±æ‡‰è©²æ¡ç”¨èˆ‡ Chat Engine ç›¸åŒçš„è¨­è¨ˆæ¨¡å¼ï¼Œä½¿ç”¨ç´” event é€šè¨Šå’Œç°¡åŒ–çš„ç‹€æ…‹ç®¡ç†ã€‚

ç¸½çµ
é€™å€‹ tool-call ç³»çµ±åŠŸèƒ½å¾ˆå®Œæ•´ï¼Œä½†æ¶æ§‹ä¸Šæœ‰æ”¹é€²ç©ºé–“ï¼š

ç§»é™¤ callbackï¼Œç´”ç”¨ event - èˆ‡ç³»çµ±å…¶ä»–éƒ¨åˆ†ä¿æŒä¸€è‡´
ä½¿ç”¨ AI SDK æ¨™æº–é¡å‹ - æ¸›å°‘é‡è¤‡å®šç¾©ï¼Œæå‡äº’æ“ä½œæ€§
ç°¡åŒ–ç‹€æ…‹ç®¡ç† - æ¸›å°‘è¤‡é›œçš„ç‹€æ…‹è½‰æ›é‚è¼¯
å®Œæˆ MCP çœŸå¯¦å¯¦ç¾ - ç›®å‰é‚„æ˜¯ mock
ä½ å° callback vs event çš„è§€å¯Ÿå¾ˆæº–ç¢º - é€™ç¢ºå¯¦æ˜¯ç³»çµ±è¨­è¨ˆä¸ä¸€è‡´çš„åœ°æ–¹ï¼Œæ‡‰è©²çµ±ä¸€ä½¿ç”¨ EventBus æ¨¡å¼ã€‚

ä½ è¦ºå¾—é€™å€‹åˆ†æå¦‚ä½•ï¼Ÿæœ‰å…¶ä»–ä½ æƒ³è¨è«–çš„è¨­è¨ˆé¢å‘å—ï¼Ÿ




Retry
ToolCallScheduler -> æ”¹å? æœ‰å“ªäº›å»ºè­°çš„åå­—ï¼Ÿ
ä½ æœƒå¦‚ä½•ç°¡åŒ– tool call systemï¼ŸåŒ…å« ChatSession è¦å¦‚ä½•ä½¿ç”¨ tool call systemï¼Ÿè«‹çµ¦ä½ çš„è¨­è¨ˆæ–¹æ¡ˆ
Edit

Strategized tool call system renaming and architectural simplification.
15s










å¾ˆå¥½çš„å•é¡Œï¼è®“æˆ‘é‡å°é€™å…©å€‹è¨­è¨ˆå•é¡Œæä¾›åˆ†æå’Œå»ºè­°ã€‚

1. ToolCallScheduler æ”¹åå»ºè­°
ç¾åœ¨çš„å•é¡Œï¼šScheduler æš—ç¤ºä¸»è¦åŠŸèƒ½æ˜¯èª¿åº¦ï¼Œä½†å¯¦éš›ä¸Šé€™å€‹é¡è² è²¬æ•´å€‹å·¥å…·èª¿ç”¨ç”Ÿå‘½é€±æœŸç®¡ç†ã€‚

å»ºè­°çš„åå­—ï¼š

ToolCallManager â­ (æ¨è–¦)
æ¸…æ¥šè¡¨é”ç®¡ç†å·¥å…·èª¿ç”¨çš„è·è²¬
ç¬¦åˆç³»çµ±ä¸­å…¶ä»– Manager é¡çš„å‘½åæ…£ä¾‹
ToolCallService
èˆ‡ç³»çµ±ä¸­å…¶ä»– Service é¡ä¸€è‡´
è¡¨é”æœå‹™åŒ–çš„è¨­è¨ˆç†å¿µ
ToolRunner
ç°¡æ½”ï¼Œç›´æ¥è¡¨é”é‹è¡Œå·¥å…·çš„æ ¸å¿ƒåŠŸèƒ½
é¿å…éåº¦æ­£å¼çš„å‘½å
æˆ‘å‚¾å‘ ToolCallManagerï¼Œå› ç‚ºå®ƒæº–ç¢ºæè¿°äº†é¡çš„è·è²¬ç¯„åœã€‚

2. ç°¡åŒ– Tool Call System è¨­è¨ˆæ–¹æ¡ˆ
ç•¶å‰æ¶æ§‹å•é¡Œåˆ†æ
typescript
// å•é¡Œ 1: éå¤šç‹€æ…‹
type ToolCallStatus = "validating" | "scheduled" | "executing" | "success" | "error" | "cancelled" | "awaiting_approval"

// å•é¡Œ 2: è¤‡é›œçš„ç‹€æ…‹è½‰æ›é‚è¼¯
private setStatusInternal(messageId, targetCallId, newStatus, auxiliaryData?, extraData?) {
  // 100+ è¡Œçš„è¤‡é›œé‚è¼¯
}

// å•é¡Œ 3: Callback æ¶æ§‹ä¸ä¸€è‡´
private outputUpdateHandler?: OutputUpdateHandler
ç°¡åŒ–è¨­è¨ˆæ–¹æ¡ˆ
æ ¸å¿ƒç°¡åŒ–åŸå‰‡
æ¸›å°‘ç‹€æ…‹è¤‡é›œæ€§ - å¾ 7 å€‹ç‹€æ…‹æ¸›å°‘åˆ° 4 å€‹æ ¸å¿ƒç‹€æ…‹
ç´” Event-Driven - ç§»é™¤æ‰€æœ‰ callbackï¼Œçµ±ä¸€ä½¿ç”¨ EventBus
è‡ªç„¶çš„ ChatSession é›†æˆ - è®“å·¥å…·èª¿ç”¨æ„Ÿè¦ºåƒå°è©±çš„è‡ªç„¶å»¶ä¼¸
ç°¡åŒ–å¾Œçš„ç‹€æ…‹æ©Ÿ
typescript
// ç°¡åŒ–åˆ° 4 å€‹æ ¸å¿ƒç‹€æ…‹
type ToolCallStatus = 
  | "pending"           // åˆå§‹ç‹€æ…‹ï¼ŒåŒ…å«é©—è­‰å’Œæ¬Šé™æª¢æŸ¥
  | "executing"         // æ­£åœ¨åŸ·è¡Œ
  | "completed"         // å®Œæˆï¼ˆæˆåŠŸæˆ–å¤±æ•—éƒ½åœ¨é€™è£¡ï¼‰
  | "waiting_approval"  // ç­‰å¾…ç”¨æˆ¶ç¢ºèª

// çµæœåœ¨ completed ç‹€æ…‹ä¸­ç”¨ result å€åˆ†
interface CompletedToolCall {
  status: "completed"
  result: { success: true, data: any } | { success: false, error: string }
}
Event-Driven æ¶æ§‹
typescript
// ç§»é™¤æ‰€æœ‰ callbackï¼Œç´”ç”¨äº‹ä»¶
class ToolCallManager {
  constructor(eventBus: IEventBus, toolRegistry: ToolRegistry) {
    // ä¸å†æ¥å— callback åƒæ•¸
  }

  async execute(requests: ToolCallRequest[], context: ChatContext) {
    // ç›´æ¥é€é eventBus ç™¼é€æ‰€æœ‰æ›´æ–°
    this.eventBus.emit({
      kind: "TOOL_CALL_STARTED",
      context,
      toolCalls: requests.map(r => ({ ...r, status: "pending" }))
    })
    
    // è™•ç†é‚è¼¯...
  }
}
ChatSession èˆ‡ Tool Call é›†æˆè¨­è¨ˆ
è‡ªç„¶çš„é›†æˆæµç¨‹
typescript
// ChatSession ä¸­çš„è¨­è¨ˆ
class ChatSession {
  private toolCallManager: ToolCallManager

  async runTurn(input: TurnInput): Promise<ConversationResult> {
    // 1. ç”Ÿæˆ AI å›æ‡‰
    const aiResponse = await this.generateModelResponse()
    
    if (aiResponse.hasToolCalls) {
      // 2. ç›´æ¥å§”è¨—çµ¦ ToolCallManager
      await this.toolCallManager.execute(aiResponse.toolCalls, {
        chatId: this.id,
        messageId: this.getCurrentMessageId()
      })
      
      // 3. ç›£è½å·¥å…·åŸ·è¡Œå®Œæˆäº‹ä»¶
      return this.waitForToolCompletion()
    }
    
    return { status: 'complete', content: aiResponse.content }
  }

  private async waitForToolCompletion(): Promise<ConversationResult> {
    // é€é event ç›£è½å·¥å…·åŸ·è¡Œçµæœ
    for await (const [event] of this.eventBus.toIterable("TOOL_CALL_COMPLETED")) {
      if (event.context.chatId === this.id) {
        // æ ¹æ“šå·¥å…·åŸ·è¡Œçµæœæ±ºå®šä¸‹ä¸€æ­¥
        return this.processToolResults(event.results)
      }
    }
  }
}
äº‹ä»¶é©…å‹•çš„æ¬Šé™è™•ç†
typescript
// ç•¶éœ€è¦ç”¨æˆ¶ç¢ºèªæ™‚
class ChatSession {
  async runTurn(input: TurnInput): Promise<ConversationResult> {
    // ... AI å›æ‡‰è™•ç†
    
    // ç›£è½æ¬Šé™è«‹æ±‚äº‹ä»¶
    this.eventBus.subscribe("TOOL_PERMISSION_REQUEST", (event) => {
      if (event.context.chatId === this.id) {
        // è¿”å› waiting_confirmation ç‹€æ…‹
        return { 
          status: 'waiting_confirmation', 
          toolCalls: event.toolCalls 
        }
      }
    })
  }

  // ç”¨æˆ¶ç¢ºèªå¾Œ
  async confirmToolCall(toolCallId: string, outcome: "approved" | "denied") {
    this.eventBus.emit({
      kind: "TOOL_PERMISSION_RESPONSE",
      toolCallId,
      outcome,
      context: { chatId: this.id }
    })
    
    // ç¹¼çºŒç­‰å¾…å·¥å…·åŸ·è¡Œå®Œæˆ
    return this.waitForToolCompletion()
  }
}
å®Œæ•´çš„ç°¡åŒ–æ¶æ§‹
æ ¸å¿ƒçµ„ä»¶è·è²¬åˆ†é›¢
typescript
// 1. ToolCallManager - ç´”ç²¹çš„å·¥å…·åŸ·è¡Œç®¡ç†
class ToolCallManager {
  // è·è²¬ï¼šç®¡ç†å·¥å…·åŸ·è¡Œç”Ÿå‘½é€±æœŸï¼Œç™¼é€äº‹ä»¶
  async execute(requests, context) { /* ç°¡åŒ–çš„åŸ·è¡Œé‚è¼¯ */ }
}

// 2. ToolRegistry - å·¥å…·è¨»å†Šå’Œç™¼ç¾
class ToolRegistry {
  // è·è²¬ï¼šç®¡ç†å¯ç”¨å·¥å…·ï¼ŒåŒ…æ‹¬ MCP æ•´åˆ
  registerTool(tool) { /* ... */ }
  getTool(name) { /* ... */ }
}

// 3. ChatSession - å°è©±ç®¡ç†
class ChatSession {
  // è·è²¬ï¼šç®¡ç†å°è©±æµç¨‹ï¼Œå”èª¿å·¥å…·èª¿ç”¨
  async runTurn(input) { /* ä½¿ç”¨ ToolCallManager */ }
}
äº‹ä»¶æµè¨­è¨ˆ
typescript
// ç°¡åŒ–çš„äº‹ä»¶æµ
"TOOL_CALL_STARTED" â†’ "TOOL_PERMISSION_REQUEST"? â†’ "TOOL_CALL_EXECUTING" â†’ "TOOL_CALL_COMPLETED"
                                   â†“
                           "TOOL_PERMISSION_RESPONSE"
èˆ‡ AI SDK é¡å‹çµ±ä¸€
typescript
// ä½¿ç”¨ AI SDK æ¨™æº–é¡å‹
import { ToolCall, ToolInvocation } from 'ai'

// åªåœ¨éœ€è¦æ™‚æ“´å±•
interface EnhancedToolCall extends ToolCall {
  status: ToolCallStatus
  context: ChatContext
}
ç¸½çµ
ç°¡åŒ–çš„æ ¸å¿ƒæ”¹é€²ï¼š

å‘½åï¼šToolCallScheduler â†’ ToolCallManager
ç‹€æ…‹ï¼š7 å€‹ç‹€æ…‹ â†’ 4 å€‹æ ¸å¿ƒç‹€æ…‹
é€šè¨Šï¼šCallback â†’ ç´” Event-driven
é›†æˆï¼šè¤‡é›œè€¦åˆ â†’ ChatSession è‡ªç„¶å§”è¨—
é¡å‹ï¼šè‡ªå®šç¾© â†’ AI SDK æ¨™æº–é¡å‹
é€™æ¨£çš„è¨­è¨ˆè®“ tool call ç³»çµ±èˆ‡ chat-engine ä¿æŒæ¶æ§‹ä¸€è‡´æ€§ï¼ŒåŒæ™‚å¤§å¹…ç°¡åŒ–äº†è¤‡é›œåº¦ã€‚

ä½ è¦ºå¾—é€™å€‹ç°¡åŒ–æ–¹å‘å¦‚ä½•ï¼Ÿæœ‰å“ªäº›éƒ¨åˆ†éœ€è¦é€²ä¸€æ­¥è¨è«–ï¼Ÿ




Retry
ç•¶å‰ chat session æ˜¯å¦‚ä½•ä½¿ç”¨ tool call schedulerï¼Ÿ
æˆ‘ä¸å¤ªå–œæ­¡ç”¨ event çš„æ–¹å¼ä¾†é€£æ¥ chat session <-> tool call schedulerï¼Œæ„Ÿè¦ºåè€ŒæœƒæŠŠåŸæœ¬ç°¡å–®çš„æ±è¥¿è®Šè¤‡é›œ

Edit

é‡æ–°æ€è€ƒå·¥å…·èª¿ç”¨è¨­è¨ˆï¼Œæå€¡ç›´æ¥æ–¹æ³•èª¿ç”¨
18s







ä½ èªªå¾—å°ï¼è®“æˆ‘å…ˆçœ‹çœ‹ç•¶å‰çš„å¯¦ç¾ï¼Œç„¶å¾Œé‡æ–°æ€è€ƒé€™å€‹è¨­è¨ˆã€‚

ç•¶å‰ Chat Session ä½¿ç”¨ Tool Call çš„æ–¹å¼
æŸ¥çœ‹ chat-session.tsï¼Œç›®å‰çš„ç‹€æ³æ˜¯ï¼š

typescript
// ChatSession åˆå§‹åŒ–æ™‚å‰µå»º ToolCallScheduler
private initializeToolSystem(): void {
  this.toolCallScheduler = new ToolCallScheduler({
    toolRegistry: Promise.resolve(this.toolRegistry),
    eventBus: this.eventBus,
    logger: this.logger,
    // é€é callback æ¥æ”¶æ›´æ–°
    outputUpdateHandler: (toolCallId, chunk) => { /* ... */ },
    onAllToolCallsComplete: (completedCalls) => { /* ... */ },
    onToolCallsUpdate: (toolCalls) => { /* ... */ }
  });
}

// ä½†å¯¦éš›çš„å·¥å…·åŸ·è¡Œé‚„æ˜¯ placeholderï¼
private async executeTools(toolCalls: ToolCall[]): Promise<ToolResults> {
  // TODO: Replace with actual tool execution
  return {
    type: 'tool_results',
    results: toolCalls.map(call => ({
      id: call.id,
      result: `Placeholder result for ${call.name}`,
    })),
  };
}
ç™¼ç¾ï¼šChatSession æœ‰åˆå§‹åŒ– ToolCallSchedulerï¼Œä½†å¯¦éš›é‚„æ²’æœ‰çœŸæ­£æ•´åˆä½¿ç”¨ï¼

ä½ çš„è§€é»å¾ˆå°
Event-driven åœ¨é€™å€‹å ´æ™¯ç¢ºå¯¦æœƒéåº¦è¤‡é›œåŒ–ï¼š

typescript
// Event æ–¹å¼ - è¤‡é›œä¸”é–“æ¥
await toolManager.execute(toolCalls)
// ç„¶å¾Œè¦ç›£è½å„ç¨®äº‹ä»¶...
this.eventBus.subscribe("TOOL_COMPLETED", ...)
this.eventBus.subscribe("TOOL_NEEDS_APPROVAL", ...)
// ç‹€æ…‹åˆ†æ•£åœ¨å¤šå€‹äº‹ä»¶ç›£è½å™¨ä¸­
vs

typescript
// ç›´æ¥æ–¹å¼ - ç°¡å–®ç›´è§€
const result = await toolManager.execute(toolCalls)
if (result.needsApproval) {
  return { status: 'waiting_confirmation', toolCalls: result.pendingTools }
}
return { status: 'complete', toolResults: result.completed }
æ›´ç°¡å–®çš„è¨­è¨ˆæ–¹æ¡ˆ
æ ¸å¿ƒç†å¿µï¼šç›´æ¥èª¿ç”¨ + ç•°å¸¸è™•ç†
typescript
class ChatSession {
  private toolManager: ToolCallManager

  async runTurn(input: TurnInput): Promise<ConversationResult> {
    const aiResponse = await this.generateModelResponse()
    
    if (aiResponse.hasToolCalls) {
      try {
        // ç›´æ¥èª¿ç”¨ï¼Œç­‰å¾…çµæœ
        const toolResults = await this.toolManager.execute(
          aiResponse.toolCalls,
          { chatId: this.id, signal: this.abortSignal }
        )
        
        // ç¹¼çºŒå°è©±æµç¨‹
        return this.continueWithToolResults(toolResults)
        
      } catch (error) {
        if (error instanceof ToolApprovalNeededError) {
          // éœ€è¦ç”¨æˆ¶ç¢ºèª
          return {
            status: 'waiting_confirmation',
            toolCalls: error.pendingToolCalls
          }
        }
        throw error
      }
    }
    
    return { status: 'complete', content: aiResponse.content }
  }
}
ToolCallManager ç°¡åŒ–è¨­è¨ˆ
typescript
class ToolCallManager {
  async execute(
    toolCalls: ToolCall[], 
    context: { chatId: string, signal?: AbortSignal }
  ): Promise<ToolResult[]> {
    
    const results: ToolResult[] = []
    const pendingApprovals: ToolCall[] = []
    
    for (const toolCall of toolCalls) {
      const tool = this.toolRegistry.getTool(toolCall.name)
      
      // æª¢æŸ¥æ˜¯å¦éœ€è¦ç¢ºèª
      const needsApproval = await tool.needsConfirmation(toolCall.args)
      if (needsApproval) {
        pendingApprovals.push(toolCall)
        continue
      }
      
      // ç›´æ¥åŸ·è¡Œ
      const result = await tool.execute(toolCall.args, { signal: context.signal })
      results.push({ toolCallId: toolCall.id, result })
    }
    
    // å¦‚æœæœ‰éœ€è¦ç¢ºèªçš„å·¥å…·ï¼Œæ‹‹å‡ºç‰¹æ®Šç•°å¸¸
    if (pendingApprovals.length > 0) {
      throw new ToolApprovalNeededError(pendingApprovals, results)
    }
    
    return results
  }
  
  // ç”¨æˆ¶ç¢ºèªå¾Œç¹¼çºŒåŸ·è¡Œ
  async continueWithApproval(
    toolCalls: ToolCall[], 
    approvals: Map<string, boolean>
  ): Promise<ToolResult[]> {
    // åªåŸ·è¡Œè¢«æ‰¹å‡†çš„å·¥å…·
    const approvedCalls = toolCalls.filter(tc => approvals.get(tc.id))
    // ... åŸ·è¡Œé‚è¼¯
  }
}
ç”¨æˆ¶ç¢ºèªæµç¨‹
typescript
// ChatSession è™•ç†ç”¨æˆ¶ç¢ºèª
async confirmToolCall(toolCallId: string, approved: boolean): Promise<ConversationResult> {
  if (this.status !== 'waiting_confirmation') {
    throw new Error('No pending tool confirmations')
  }
  
  // ç›´æ¥èª¿ç”¨ç¹¼çºŒåŸ·è¡Œ
  const toolResults = await this.toolManager.continueWithApproval(
    this.pendingToolCalls,
    new Map([[toolCallId, approved]])
  )
  
  return this.continueWithToolResults(toolResults)
}
æ¯”è¼ƒå…©ç¨®æ–¹æ¡ˆ
Event-Driven æ–¹å¼
âŒ ç‹€æ…‹åˆ†æ•£åœ¨å¤šå€‹äº‹ä»¶ç›£è½å™¨
âŒ ç•°æ­¥æµç¨‹é›£ä»¥è¿½è¹¤
âŒ éŒ¯èª¤è™•ç†è¤‡é›œ
âŒ èª¿è©¦å›°é›£

ç›´æ¥èª¿ç”¨æ–¹å¼
âœ… æµç¨‹æ¸…æ™°ï¼Œä¸€ç›®äº†ç„¶
âœ… éŒ¯èª¤è™•ç†é›†ä¸­
âœ… å®¹æ˜“æ¸¬è©¦å’Œèª¿è©¦
âœ… ç¬¦åˆä¸€èˆ¬ç¨‹å¼è¨­è¨ˆç›´è¦º

ç¸½çµ
ä½ çš„ç›´è¦ºæ˜¯å°çš„ï¼ç›´æ¥æ–¹æ³•èª¿ç”¨ + ç•°å¸¸è™•ç†æ¯” event-driven æ›´é©åˆé€™å€‹å ´æ™¯ï¼Œå› ç‚ºï¼š

ChatSession â†” ToolManager æ˜¯ä¸€å°ä¸€çš„ç·Šå¯†åˆä½œé—œä¿‚ï¼Œä¸æ˜¯é¬†è€¦åˆçš„ç™¼å¸ƒè¨‚é–±å ´æ™¯
å·¥å…·åŸ·è¡Œæ˜¯åŒæ­¥å¼çš„è«‹æ±‚-å›æ‡‰æ¨¡å¼ï¼Œä¸éœ€è¦è¤‡é›œçš„äº‹ä»¶å”èª¿
éŒ¯èª¤å’Œç•°å¸¸ç‹€æ³ï¼ˆå¦‚éœ€è¦ç¢ºèªï¼‰ç”¨ç•°å¸¸æ©Ÿåˆ¶è™•ç†æ›´è‡ªç„¶
Event-driven æ›´é©åˆè·¨æ¨¡çµ„çš„é€šçŸ¥ï¼ˆå¦‚ UI æ›´æ–°ã€æ—¥èªŒè¨˜éŒ„ï¼‰ï¼Œè€Œä¸æ˜¯æ ¸å¿ƒæ¥­å‹™é‚è¼¯çš„å”èª¿ã€‚

é€™æ¨£çš„è¨­è¨ˆæ—¢ä¿æŒäº†ç°¡æ½”æ€§ï¼Œåˆé¿å…äº†éåº¦è¨­è¨ˆçš„é™·é˜±ã€‚ä½ è¦ºå¾—é€™å€‹æ–¹å‘å¦‚ä½•ï¼Ÿ




Retry
const results: ToolResult[] = []
    const pendingApprovals: ToolCall[] = []

ä½ ç¾åœ¨æ˜¯æƒ³æŠŠ tool calls ç”¨ ToolCallManager ä¾†å„²å­˜ï¼Œä½†æˆ‘æƒ³çš„æ˜¯ï¼Œå¯ä»¥ç”± chat session ä¾†å„²å­˜ï¼Œsession æœ¬ä¾†å°±æ˜¯åœ¨å„²å­˜ chat state
ToolCallScheduler ä½œç‚º statelessï¼Œåªè² è²¬tool callçš„é‹è¡Œï¼Ÿ
é€™æ¨£å¦‚ä½•ï¼Ÿ

Edit

Reimagined tool call management with session-centric approach.
10s










ä½ çš„æƒ³æ³•éå¸¸æ­£ç¢ºï¼é€™æ¨£çš„è·è²¬åˆ†é›¢æ›´æ¸…æ™°ã€æ›´åˆç†ã€‚

é‡æ–°è¨­è¨ˆï¼šChatSession ç®¡ç†ç‹€æ…‹ï¼ŒToolCallManager ç„¡ç‹€æ…‹
è·è²¬é‡æ–°åˆ†é…
typescript
// ChatSession - è² è²¬ç‹€æ…‹ç®¡ç†
class ChatSession {
  // å„²å­˜å·¥å…·èª¿ç”¨ç›¸é—œç‹€æ…‹
  private pendingToolCalls: ToolCall[] = []
  private completedToolResults: ToolResult[] = []
  private toolCallsAwaitingApproval: ToolCall[] = []
  
  // å…¶ä»–ç¾æœ‰ç‹€æ…‹
  messages: ChatMessage[] = []
  status: ChatStatus = 'idle'
  // ...
}

// ToolCallManager - ç´”ç²¹çš„åŸ·è¡Œå¼•æ“ï¼Œç„¡ç‹€æ…‹
class ToolCallManager {
  // ä¸å„²å­˜ä»»ä½•ç‹€æ…‹ï¼Œç´”ç²¹çš„ stateless service
  async execute(toolCalls: ToolCall[]): Promise<ToolExecutionResult>
  async executeSingle(toolCall: ToolCall): Promise<ToolResult>
  // ...
}
å…·é«”æµç¨‹è¨­è¨ˆ
typescript
class ChatSession {
  async runTurn(input: TurnInput): Promise<ConversationResult> {
    const aiResponse = await this.generateModelResponse()
    
    if (aiResponse.hasToolCalls) {
      // 1. ChatSession å„²å­˜å¾…åŸ·è¡Œçš„å·¥å…·èª¿ç”¨
      this.pendingToolCalls = aiResponse.toolCalls
      
      // 2. å§”è¨—çµ¦ stateless ToolCallManager åŸ·è¡Œ
      const executionResult = await this.toolCallManager.execute(aiResponse.toolCalls)
      
      // 3. ChatSession è™•ç†åŸ·è¡Œçµæœä¸¦æ›´æ–°ç‹€æ…‹
      return this.handleToolExecutionResult(executionResult)
    }
    
    return { status: 'complete', content: aiResponse.content }
  }
  
  private handleToolExecutionResult(result: ToolExecutionResult): ConversationResult {
    // ChatSession è² è²¬ç‹€æ…‹æ›´æ–°
    this.completedToolResults.push(...result.executed)
    
    if (result.needsApproval.length > 0) {
      // æ›´æ–° session ç‹€æ…‹
      this.toolCallsAwaitingApproval = result.needsApproval
      this.status = 'waiting_confirmation'
      
      return {
        status: 'waiting_confirmation',
        toolCalls: result.needsApproval.map(tc => ({
          id: tc.id,
          name: tc.name,
          arguments: tc.arguments,
          needsConfirmation: true
        }))
      }
    }
    
    // æ‰€æœ‰å·¥å…·éƒ½åŸ·è¡Œå®Œæˆï¼Œç¹¼çºŒå°è©±
    return this.continueAfterToolExecution()
  }
}
Stateless ToolCallManager è¨­è¨ˆ
typescript
interface ToolExecutionResult {
  executed: ToolResult[]        // æˆåŠŸåŸ·è¡Œçš„å·¥å…·çµæœ
  needsApproval: ToolCall[]     // éœ€è¦ç”¨æˆ¶ç¢ºèªçš„å·¥å…·
  failed: ToolError[]           // åŸ·è¡Œå¤±æ•—çš„å·¥å…·
}

class ToolCallManager {
  // å®Œå…¨ statelessï¼Œä¸å„²å­˜ä»»ä½•ç‹€æ…‹
  async execute(toolCalls: ToolCall[]): Promise<ToolExecutionResult> {
    const executed: ToolResult[] = []
    const needsApproval: ToolCall[] = []
    const failed: ToolError[] = []
    
    // è™•ç†æ¯å€‹å·¥å…·èª¿ç”¨
    for (const toolCall of toolCalls) {
      try {
        const tool = this.toolRegistry.getTool(toolCall.name)
        
        // æª¢æŸ¥æ˜¯å¦éœ€è¦ç¢ºèª
        if (await tool.needsConfirmation(toolCall.arguments)) {
          needsApproval.push(toolCall)
          continue
        }
        
        // åŸ·è¡Œå·¥å…·
        const result = await tool.execute(toolCall.arguments)
        executed.push({ toolCallId: toolCall.id, result })
        
      } catch (error) {
        failed.push({ toolCallId: toolCall.id, error })
      }
    }
    
    // è¿”å›çµæœï¼Œä¸å„²å­˜ç‹€æ…‹
    return { executed, needsApproval, failed }
  }
  
  // å–®ç´”åŸ·è¡Œå·²æ‰¹å‡†çš„å·¥å…·ï¼Œä¸ç®¡ç†ç‹€æ…‹
  async executeApproved(approvedToolCalls: ToolCall[]): Promise<ToolResult[]> {
    // åŒæ¨£æ˜¯ stateless çš„ç´”ç²¹åŸ·è¡Œ
    const results: ToolResult[] = []
    
    for (const toolCall of approvedToolCalls) {
      const tool = this.toolRegistry.getTool(toolCall.name)
      const result = await tool.execute(toolCall.arguments)
      results.push({ toolCallId: toolCall.id, result })
    }
    
    return results
  }
}
ç”¨æˆ¶ç¢ºèªæµç¨‹
typescript
// ChatSession è™•ç†ç”¨æˆ¶ç¢ºèª
async confirmToolCall(toolCallId: string, approved: boolean): Promise<ConversationResult> {
  if (this.status !== 'waiting_confirmation') {
    throw new Error('No pending tool confirmations')
  }
  
  // ChatSession ç®¡ç†ç¢ºèªç‹€æ…‹
  const toolCall = this.toolCallsAwaitingApproval.find(tc => tc.id === toolCallId)
  if (!toolCall) {
    throw new Error(`Tool call ${toolCallId} not found in pending approvals`)
  }
  
  if (approved) {
    // å§”è¨—çµ¦ stateless manager åŸ·è¡Œ
    const results = await this.toolCallManager.executeApproved([toolCall])
    
    // ChatSession æ›´æ–°ç‹€æ…‹
    this.completedToolResults.push(...results)
  }
  
  // å¾å¾…ç¢ºèªåˆ—è¡¨ç§»é™¤
  this.toolCallsAwaitingApproval = this.toolCallsAwaitingApproval.filter(tc => tc.id !== toolCallId)
  
  // æª¢æŸ¥æ˜¯å¦é‚„æœ‰å¾…ç¢ºèªçš„å·¥å…·
  if (this.toolCallsAwaitingApproval.length === 0) {
    this.status = 'idle'
    return this.continueAfterToolExecution()
  }
  
  // é‚„æœ‰å…¶ä»–å·¥å…·ç­‰å¾…ç¢ºèª
  return {
    status: 'waiting_confirmation',
    toolCalls: this.toolCallsAwaitingApproval.map(tc => ({ /* ... */ }))
  }
}
é€™æ¨£è¨­è¨ˆçš„å„ªé»
1. æ¸…æ™°çš„è·è²¬åˆ†é›¢
ChatSession: å°è©±ç‹€æ…‹ç®¡ç†è€…
ToolCallManager: ç´”ç²¹çš„å·¥å…·åŸ·è¡Œå¼•æ“
2. ç¬¦åˆç¾æœ‰æ¶æ§‹
ChatSession æœ¬ä¾†å°±åœ¨ç®¡ç† messagesã€status ç­‰ç‹€æ…‹
å·¥å…·èª¿ç”¨ç‹€æ…‹è‡ªç„¶å±¬æ–¼å°è©±ç‹€æ…‹çš„ä¸€éƒ¨åˆ†
3. æ˜“æ–¼æ¸¬è©¦å’Œèª¿è©¦
typescript
// ToolCallManager å®Œå…¨å¯é æ¸¬ï¼Œç„¡å‰¯ä½œç”¨
const result = await toolManager.execute(toolCalls)
// è¼¸å…¥ç›¸åŒï¼Œè¼¸å‡ºå¿…å®šç›¸åŒ

// ChatSession çš„ç‹€æ…‹è®ŠåŒ–ä¹Ÿå¾ˆæ¸…æ¥š
console.log(session.pendingToolCalls)
console.log(session.completedToolResults)
4. æŒä¹…åŒ–è‡ªç„¶
typescript
// ChatSession åºåˆ—åŒ–æ™‚åŒ…å«å·¥å…·ç‹€æ…‹
toJSON(): SerializableChat {
  return {
    // ...
    pendingToolCalls: this.pendingToolCalls,
    completedToolResults: this.completedToolResults,
    toolCallsAwaitingApproval: this.toolCallsAwaitingApproval
  }
}
é€™æ¨£çš„è¨­è¨ˆæ—¢ä¿æŒäº†ç°¡æ½”æ€§ï¼Œåˆè®“è·è²¬åˆ†å·¥æ›´æ¸…æ™°ã€‚ChatSession ä½œç‚ºç‹€æ…‹å®¹å™¨ï¼ŒToolCallManager ä½œç‚ºç„¡ç‹€æ…‹çš„åŸ·è¡Œå¼•æ“ï¼Œé€™æ˜¯å¾ˆå¥½çš„æ¶æ§‹æ±ºç­–ï¼




Retry
ç›®å‰çš„ tool-call-scheduler.ts æ˜¯ stateless å—ï¼Ÿ

Edit

åˆ¤æ–·å·¥å…·èª¿ç”¨èª¿åº¦å™¨ä¸æ˜¯ç„¡ç‹€æ…‹çš„ã€‚
13s







ä¸æ˜¯ï¼Œç›®å‰çš„ ToolCallScheduler æ˜¯ stateful çš„ã€‚

è®“æˆ‘æŒ‡å‡ºå®ƒå„²å­˜çš„ç‹€æ…‹ï¼š

ToolCallScheduler çš„ç‹€æ…‹
typescript
export class ToolCallScheduler {
  // æ ¸å¿ƒç‹€æ…‹å„²å­˜
  private toolCalls: Map<string, ToolCall[]> = new Map() // messageId -> ToolCall[]
  private pendingConfirmations: Map<string, WaitingToolCall> = new Map()
  
  // å…¶ä»–é…ç½®ç‹€æ…‹
  private outputUpdateHandler?: OutputUpdateHandler
  private onAllToolCallsComplete?: AllToolCallsCompleteHandler
  private onToolCallsUpdate?: ToolCallsUpdateHandler
}
æ˜é¡¯çš„ Stateful è¡Œç‚º
typescript
// 1. å„²å­˜å·¥å…·èª¿ç”¨ç‹€æ…‹
async execute(...) {
  // å„²å­˜åˆ°å…§éƒ¨ç‹€æ…‹
  this.toolCalls.set(messageId, newToolCalls)
  this.notifyToolCallsUpdate(messageId)
}

// 2. æŸ¥è©¢ç‹€æ…‹çš„æ–¹æ³•
getToolCalls(messageId: string): ToolCall[] {
  return this.toolCalls.get(messageId) || []
}

getPendingApprovals(): WaitingToolCall[] {
  return Array.from(this.pendingConfirmations.values())
}

// 3. ç‹€æ…‹ä¿®æ”¹æ–¹æ³•
private setStatusInternal(messageId, targetCallId, newStatus, ...) {
  const toolCalls = this.toolCalls.get(messageId) || []
  // ä¿®æ”¹ç‹€æ…‹...
  this.toolCalls.set(messageId, updatedToolCalls)
}
é€™è­‰å¯¦äº†ä½ çš„æƒ³æ³•æ˜¯å°çš„
ç¾åœ¨çš„æ¶æ§‹å…¶å¯¦æ˜¯é›™é‡ç‹€æ…‹ç®¡ç†ï¼š

typescript
// ChatSession æœ‰è‡ªå·±çš„ç‹€æ…‹
class ChatSession {
  messages: ChatMessage[] = []
  status: ChatStatus = 'idle' 
  // ...
}

// ToolCallScheduler ä¹Ÿæœ‰è‡ªå·±çš„ç‹€æ…‹
class ToolCallScheduler {
  private toolCalls: Map<string, ToolCall[]> = new Map()
  private pendingConfirmations: Map<string, WaitingToolCall> = new Map()
}
é€™é€ æˆäº†ï¼š

ç‹€æ…‹åˆ†æ•£ - å·¥å…·èª¿ç”¨ç‹€æ…‹åˆ†æ•£åœ¨å…©å€‹åœ°æ–¹
åŒæ­¥å•é¡Œ - å…©å€‹ç‹€æ…‹ç®¡ç†å™¨å¯èƒ½ä¸ä¸€è‡´
è¤‡é›œæ€§ - éœ€è¦å”èª¿å…©å¥—ç‹€æ…‹ç³»çµ±
ä½ å»ºè­°çš„æ”¹é€²
typescript
// ChatSession - çµ±ä¸€çš„ç‹€æ…‹ç®¡ç†
class ChatSession {
  messages: ChatMessage[] = []
  status: ChatStatus = 'idle'
  
  // å·¥å…·èª¿ç”¨ç‹€æ…‹ä¹Ÿç”± ChatSession ç®¡ç†
  pendingToolCalls: ToolCall[] = []
  completedToolResults: ToolResult[] = []
  toolCallsAwaitingApproval: ToolCall[] = []
}

// ToolCallManager - çœŸæ­£çš„ stateless
class ToolCallManager {
  // ç´”å‡½æ•¸å¼çš„åŸ·è¡Œå¼•æ“ï¼Œä¸å„²å­˜ä»»ä½•ç‹€æ…‹
  async execute(toolCalls: ToolCall[]): Promise<ToolExecutionResult> {
    // åªè² è²¬åŸ·è¡Œï¼Œä¸å„²å­˜ç‹€æ…‹
  }
}
é€™æ¨£çš„é‡æ§‹æœƒå¤§å¹…ç°¡åŒ–æ¶æ§‹ï¼š

å–®ä¸€çœŸç›¸ä¾†æº - æ‰€æœ‰ç‹€æ…‹éƒ½åœ¨ ChatSession
ç„¡ç‹€æ…‹æœå‹™ - ToolCallManager è®Šæˆç´”ç²¹çš„å·¥å…·
æ›´å®¹æ˜“æ¸¬è©¦ - stateless çµ„ä»¶æ›´å¥½æ¸¬è©¦
æ›´å®¹æ˜“åºåˆ—åŒ– - åªéœ€è¦åºåˆ—åŒ– ChatSession
ä½ çš„ç›´è¦ºå¾ˆæº–ç¢ºï¼ç•¶å‰çš„è¨­è¨ˆç¢ºå¯¦æœ‰ç‹€æ…‹ç®¡ç†åˆ†æ•£çš„å•é¡Œã€‚




Retry
async execute(toolCalls: ToolCall[]): Promise<ToolExecutionResult> {

æˆ‘å€‘æ˜¯ä¸æ˜¯å¯ä»¥ç›´æ¥åœ¨é€™è£¡çµ¦äºˆ approvesï¼Œä¾‹å¦‚ execute(toolCalls: ToolCall[], toolCallApprovals: ToolCallApproval[]?)ï¼Ÿ
é€™æ¨£ ChatSession å°±åªè¦ä¿å­˜ stateï¼Œå‰©ä¸‹çš„æ±è¥¿éƒ½äº¤çµ¦ ToolCallManager å»åš

Edit

Reimagined tool execution flow for clearer state management
6s






çµ•ä½³çš„æƒ³æ³•ï¼ é€™æ¨£è¨­è¨ˆè®“ ToolCallManager è®ŠæˆçœŸæ­£çš„ pure functionï¼Œè€Œ ChatSession åªå°ˆæ³¨æ–¼ç‹€æ…‹ç®¡ç†ã€‚

é‡æ–°è¨­è¨ˆï¼šPure Function çš„ ToolCallManager
typescript
interface ToolCallApproval {
  toolCallId: string
  approved: boolean
  timestamp?: Date
}

interface ToolExecutionResult {
  executed: ToolResult[]           // é€™æ¬¡åŸ·è¡Œå®Œæˆçš„å·¥å…·
  stillNeedsApproval: ToolCall[]   // ä»éœ€è¦ç”¨æˆ¶ç¢ºèªçš„å·¥å…·  
  failed: ToolError[]              // åŸ·è¡Œå¤±æ•—çš„å·¥å…·
}

class ToolCallManager {
  // å®Œå…¨ stateless çš„ pure function
  async execute(
    toolCalls: ToolCall[], 
    approvals?: ToolCallApproval[]
  ): Promise<ToolExecutionResult> {
    
    const approvalMap = new Map(
      approvals?.map(a => [a.toolCallId, a.approved]) || []
    )
    
    const executed: ToolResult[] = []
    const stillNeedsApproval: ToolCall[] = []
    const failed: ToolError[] = []
    
    for (const toolCall of toolCalls) {
      try {
        // æª¢æŸ¥æ˜¯å¦å·²æœ‰approvalæ±ºå®š
        const hasApproval = approvalMap.has(toolCall.id)
        const isApproved = approvalMap.get(toolCall.id)
        
        if (hasApproval && !isApproved) {
          // ç”¨æˆ¶æ‹’çµ•äº†ï¼Œè·³é
          continue
        }
        
        const tool = this.toolRegistry.getTool(toolCall.name)
        const needsConfirmation = await tool.needsConfirmation(toolCall.arguments)
        
        if (needsConfirmation && !hasApproval) {
          // éœ€è¦ç¢ºèªä½†æ²’æœ‰approval
          stillNeedsApproval.push(toolCall)
          continue
        }
        
        // å¯ä»¥åŸ·è¡Œï¼šè¦éº¼ä¸éœ€è¦ç¢ºèªï¼Œè¦éº¼å·²ç¶“è¢«æ‰¹å‡†
        const result = await tool.execute(toolCall.arguments)
        executed.push({ toolCallId: toolCall.id, result })
        
      } catch (error) {
        failed.push({ toolCallId: toolCall.id, error })
      }
    }
    
    return { executed, stillNeedsApproval, failed }
  }
}
ChatSession çš„ç°¡åŒ–ç‹€æ…‹ç®¡ç†
typescript
class ChatSession {
  // ç‹€æ…‹ç®¡ç†
  messages: ChatMessage[] = []
  status: ChatStatus = 'idle'
  
  // å·¥å…·èª¿ç”¨ç›¸é—œç‹€æ…‹
  private pendingToolCalls: ToolCall[] = []
  private toolCallApprovals: ToolCallApproval[] = []
  private completedToolResults: ToolResult[] = []
  
  async runTurn(input: TurnInput): Promise<ConversationResult> {
    const aiResponse = await this.generateModelResponse()
    
    if (aiResponse.hasToolCalls) {
      // å„²å­˜æ–°çš„å·¥å…·èª¿ç”¨
      this.pendingToolCalls = aiResponse.toolCalls
      
      // ä¸€æ¬¡æ€§åŸ·è¡Œï¼Œå‚³å…¥ç¾æœ‰çš„approvals
      const result = await this.toolCallManager.execute(
        this.pendingToolCalls,
        this.toolCallApprovals
      )
      
      return this.handleToolResult(result)
    }
    
    return { status: 'complete', content: aiResponse.content }
  }
  
  private handleToolResult(result: ToolExecutionResult): ConversationResult {
    // æ›´æ–°ç‹€æ…‹
    this.completedToolResults.push(...result.executed)
    this.pendingToolCalls = result.stillNeedsApproval
    
    if (result.stillNeedsApproval.length > 0) {
      this.status = 'waiting_confirmation'
      return {
        status: 'waiting_confirmation',
        toolCalls: result.stillNeedsApproval.map(tc => ({
          id: tc.id,
          name: tc.name,
          arguments: tc.arguments,
          needsConfirmation: true
        }))
      }
    }
    
    // æ‰€æœ‰å·¥å…·éƒ½åŸ·è¡Œå®Œæˆ
    this.status = 'idle'
    return this.continueAfterToolExecution()
  }
}
ç”¨æˆ¶ç¢ºèªçš„æ¥µç°¡æµç¨‹
typescript
async confirmToolCall(toolCallId: string, approved: boolean): Promise<ConversationResult> {
  // 1. åªéœ€è¦æ›´æ–°approvalç‹€æ…‹
  this.toolCallApprovals.push({
    toolCallId,
    approved,
    timestamp: new Date()
  })
  
  // 2. é‡æ–°åŸ·è¡Œæ‰€æœ‰pendingçš„å·¥å…·èª¿ç”¨
  const result = await this.toolCallManager.execute(
    this.pendingToolCalls,
    this.toolCallApprovals  // åŒ…å«æ–°çš„approval
  )
  
  // 3. è™•ç†çµæœ
  return this.handleToolResult(result)
}
é€™æ¨£è¨­è¨ˆçš„å„ªå‹¢
1. Pure Function çš„å¨åŠ›
typescript
// ToolCallManager.execute() è®Šæˆå®Œå…¨å¯é æ¸¬çš„ pure function
const result1 = await manager.execute(toolCalls, approvals)
const result2 = await manager.execute(toolCalls, approvals)
// result1 === result2 (ç›¸åŒè¼¸å…¥ï¼Œç›¸åŒè¼¸å‡º)
2. ç‹€æ…‹ç®¡ç†æ¥µç°¡
typescript
// ChatSession åªéœ€è¦ç¶­è­·ä¸‰å€‹ç°¡å–®çš„é™£åˆ—
private pendingToolCalls: ToolCall[] = []
private toolCallApprovals: ToolCallApproval[] = []  
private completedToolResults: ToolResult[] = []
3. é‚è¼¯çµ±ä¸€
typescript
// ä¸ç®¡æ˜¯åˆæ¬¡åŸ·è¡Œé‚„æ˜¯ç¢ºèªå¾ŒåŸ·è¡Œï¼Œéƒ½æ˜¯åŒä¸€å€‹æ–¹æ³•
await this.toolCallManager.execute(toolCalls, approvals)
4. å®¹æ˜“æ¸¬è©¦
typescript
// æ¸¬è©¦è®Šå¾—è¶…ç´šç°¡å–®
const manager = new ToolCallManager(mockRegistry)
const result = await manager.execute(
  [{ id: '1', name: 'test', arguments: {} }],
  [{ toolCallId: '1', approved: true }]
)
expect(result.executed).toHaveLength(1)
é€™å€‹è¨­è¨ˆè®“ ChatSession ç´”ç²¹åšç‹€æ…‹ç®¡ç†ï¼ŒToolCallManager ç´”ç²¹åšé‚è¼¯è™•ç†ï¼Œè·è²¬åˆ†é›¢å¾—éå¸¸æ¸…æ™°ï¼è€Œä¸”ç¢ºå¯¦æ¯”æˆ‘ä¹‹å‰æè­°çš„ event-driven æ–¹å¼ç°¡å–®å¾—å¤šã€‚




Retry
è«‹æŠŠæˆ‘å€‘è¨è«–çš„é‡æ–°æ•´ç†

Edit

é‡æ–°æ•´ç† tool-call ç³»çµ±æ¶æ§‹å’Œè¨­è¨ˆæ–¹æ¡ˆ
6s



Tool Call ç³»çµ±é‡æ§‹è¨­è¨ˆ
ç•¶å‰å•é¡Œåˆ†æ
1. æ¶æ§‹ä¸ä¸€è‡´
Chat Engine: ç´” event-drivenï¼Œæ¸…çˆ½çš„ session ç®¡ç†
Tool Call: æ··åˆ callback + eventï¼Œè¤‡é›œçš„ç‹€æ…‹ç®¡ç†
2. é›™é‡ç‹€æ…‹ç®¡ç†
typescript
// ç‹€æ…‹åˆ†æ•£åœ¨å…©å€‹åœ°æ–¹
class ChatSession {
  messages: ChatMessage[] = []
  status: ChatStatus = 'idle'
}

class ToolCallScheduler {
  private toolCalls: Map<string, ToolCall[]> = new Map()
  private pendingConfirmations: Map<string, WaitingToolCall> = new Map()
}
3. éåº¦è¤‡é›œçš„ç‹€æ…‹æ©Ÿ
7 å€‹ç‹€æ…‹ï¼švalidating | scheduled | executing | success | error | cancelled | awaiting_approval
100+ è¡Œçš„è¤‡é›œç‹€æ…‹è½‰æ›é‚è¼¯
Callback æ¶æ§‹èˆ‡ç³»çµ±å…¶ä»–éƒ¨åˆ†ä¸ä¸€è‡´
4. æœªå®Œæˆçš„æ•´åˆ
ChatSession æœ‰åˆå§‹åŒ– ToolCallSchedulerï¼Œä½†å¯¦éš›é‚„æ²’çœŸæ­£ä½¿ç”¨
executeTools() æ–¹æ³•é‚„æ˜¯ placeholder å¯¦ç¾
é‡æ§‹è¨­è¨ˆæ–¹æ¡ˆ
æ ¸å¿ƒè¨­è¨ˆåŸå‰‡
ChatSession çµ±ä¸€ç‹€æ…‹ç®¡ç† - æ‰€æœ‰ç‹€æ…‹éƒ½ç”± ChatSession ç®¡ç†
ToolCallManager ä½œç‚º Pure Function - å®Œå…¨ stateless çš„åŸ·è¡Œå¼•æ“
ç›´æ¥æ–¹æ³•èª¿ç”¨ - é¿å…éåº¦è¤‡é›œçš„ event-driven æ¶æ§‹
ç°¡åŒ–ç‹€æ…‹æ©Ÿ - æ¸›å°‘ä¸å¿…è¦çš„ä¸­é–“ç‹€æ…‹
æ–°æ¶æ§‹è¨­è¨ˆ
1. ToolCallManager (Stateless Pure Function)
typescript
interface ToolCallApproval {
  toolCallId: string
  approved: boolean
  timestamp?: Date
}

interface ToolExecutionResult {
  executed: ToolResult[]           // é€™æ¬¡åŸ·è¡Œå®Œæˆçš„å·¥å…·
  stillNeedsApproval: ToolCall[]   // ä»éœ€è¦ç”¨æˆ¶ç¢ºèªçš„å·¥å…·  
  failed: ToolError[]              // åŸ·è¡Œå¤±æ•—çš„å·¥å…·
}

class ToolCallManager {
  // å®Œå…¨ stateless çš„ pure function
  async execute(
    toolCalls: ToolCall[], 
    approvals?: ToolCallApproval[]
  ): Promise<ToolExecutionResult> {
    
    const approvalMap = new Map(
      approvals?.map(a => [a.toolCallId, a.approved]) || []
    )
    
    const executed: ToolResult[] = []
    const stillNeedsApproval: ToolCall[] = []
    const failed: ToolError[] = []
    
    for (const toolCall of toolCalls) {
      // æª¢æŸ¥approvalç‹€æ…‹
      const hasApproval = approvalMap.has(toolCall.id)
      const isApproved = approvalMap.get(toolCall.id)
      
      if (hasApproval && !isApproved) {
        continue // ç”¨æˆ¶æ‹’çµ•ï¼Œè·³é
      }
      
      const tool = this.toolRegistry.getTool(toolCall.name)
      const needsConfirmation = await tool.needsConfirmation(toolCall.arguments)
      
      if (needsConfirmation && !hasApproval) {
        stillNeedsApproval.push(toolCall)
        continue
      }
      
      // åŸ·è¡Œå·¥å…·
      try {
        const result = await tool.execute(toolCall.arguments)
        executed.push({ toolCallId: toolCall.id, result })
      } catch (error) {
        failed.push({ toolCallId: toolCall.id, error })
      }
    }
    
    return { executed, stillNeedsApproval, failed }
  }
}
2. ChatSession (çµ±ä¸€ç‹€æ…‹ç®¡ç†)
typescript
class ChatSession {
  // åŸæœ‰ç‹€æ…‹
  messages: ChatMessage[] = []
  status: ChatStatus = 'idle'
  
  // å·¥å…·èª¿ç”¨ç‹€æ…‹ï¼ˆçµ±ä¸€ç®¡ç†ï¼‰
  private pendingToolCalls: ToolCall[] = []
  private toolCallApprovals: ToolCallApproval[] = []
  private completedToolResults: ToolResult[] = []
  
  async runTurn(input: TurnInput): Promise<ConversationResult> {
    const aiResponse = await this.generateModelResponse()
    
    if (aiResponse.hasToolCalls) {
      // å„²å­˜æ–°çš„å·¥å…·èª¿ç”¨
      this.pendingToolCalls = aiResponse.toolCalls
      
      // ä¸€æ¬¡æ€§åŸ·è¡Œï¼Œå‚³å…¥ç¾æœ‰çš„approvals
      const result = await this.toolCallManager.execute(
        this.pendingToolCalls,
        this.toolCallApprovals
      )
      
      return this.handleToolResult(result)
    }
    
    return { status: 'complete', content: aiResponse.content }
  }
  
  private handleToolResult(result: ToolExecutionResult): ConversationResult {
    // æ›´æ–°ç‹€æ…‹
    this.completedToolResults.push(...result.executed)
    this.pendingToolCalls = result.stillNeedsApproval
    
    if (result.stillNeedsApproval.length > 0) {
      this.status = 'waiting_confirmation'
      return {
        status: 'waiting_confirmation',
        toolCalls: result.stillNeedsApproval.map(tc => ({
          id: tc.id,
          name: tc.name,
          arguments: tc.arguments,
          needsConfirmation: true
        }))
      }
    }
    
    // æ‰€æœ‰å·¥å…·éƒ½åŸ·è¡Œå®Œæˆ
    this.status = 'idle'
    return this.continueAfterToolExecution()
  }
  
  async confirmToolCall(toolCallId: string, approved: boolean): Promise<ConversationResult> {
    // 1. æ›´æ–°approvalç‹€æ…‹
    this.toolCallApprovals.push({
      toolCallId,
      approved,
      timestamp: new Date()
    })
    
    // 2. é‡æ–°åŸ·è¡Œæ‰€æœ‰pendingçš„å·¥å…·èª¿ç”¨
    const result = await this.toolCallManager.execute(
      this.pendingToolCalls,
      this.toolCallApprovals
    )
    
    // 3. è™•ç†çµæœ
    return this.handleToolResult(result)
  }
}
é‡æ§‹å„ªå‹¢
1. æ¶æ§‹ä¸€è‡´æ€§
ChatSession çµ±ä¸€ç‹€æ…‹ç®¡ç†ï¼Œèˆ‡ç¾æœ‰æ¶æ§‹ä¸€è‡´
ç§»é™¤é›™é‡ç‹€æ…‹ç®¡ç†çš„è¤‡é›œæ€§
2. Pure Function çš„å¨åŠ›
typescript
// ToolCallManager.execute() å®Œå…¨å¯é æ¸¬
const result1 = await manager.execute(toolCalls, approvals)
const result2 = await manager.execute(toolCalls, approvals) 
// result1 === result2 (ç›¸åŒè¼¸å…¥ï¼Œç›¸åŒè¼¸å‡º)
3. ç°¡åŒ–çš„ç‹€æ…‹ç®¡ç†
typescript
// åªéœ€è¦ä¸‰å€‹ç°¡å–®çš„é™£åˆ—
private pendingToolCalls: ToolCall[] = []
private toolCallApprovals: ToolCallApproval[] = []  
private completedToolResults: ToolResult[] = []
4. çµ±ä¸€çš„åŸ·è¡Œé‚è¼¯
typescript
// åˆæ¬¡åŸ·è¡Œå’Œç¢ºèªå¾ŒåŸ·è¡Œéƒ½æ˜¯åŒä¸€å€‹æ–¹æ³•
await this.toolCallManager.execute(toolCalls, approvals)
5. å®¹æ˜“æ¸¬è©¦
typescript
// æ¸¬è©¦è®Šå¾—è¶…ç´šç°¡å–®
const manager = new ToolCallManager(mockRegistry)
const result = await manager.execute(
  [{ id: '1', name: 'test', arguments: {} }],
  [{ toolCallId: '1', approved: true }]
)
expect(result.executed).toHaveLength(1)
6. è‡ªç„¶çš„æŒä¹…åŒ–
typescript
// ChatSession åºåˆ—åŒ–æ™‚åŒ…å«æ‰€æœ‰ç‹€æ…‹
toJSON(): SerializableChat {
  return {
    // åŸæœ‰å­—æ®µ...
    pendingToolCalls: this.pendingToolCalls,
    toolCallApprovals: this.toolCallApprovals,
    completedToolResults: this.completedToolResults
  }
}
å…¶ä»–æ”¹é€²
1. å‘½å
ToolCallScheduler â†’ ToolCallManager

2. èˆ‡ AI SDK é¡å‹çµ±ä¸€
typescript
import { ToolCall, ToolInvocation } from 'ai'

// åªåœ¨éœ€è¦æ™‚æ“´å±•
interface EnhancedToolCall extends ToolCall {
  // é¡å¤–å­—æ®µ...
}
3. MCP æ•´åˆ
ä¿æŒç¾æœ‰çš„ MCP æ¶æ§‹ï¼Œä½†ç°¡åŒ–ç‹€æ…‹ç®¡ç†éƒ¨åˆ†

ç¸½çµ
é€™å€‹é‡æ§‹æ–¹æ¡ˆçš„æ ¸å¿ƒæ˜¯ï¼šChatSession å°ˆæ³¨æ–¼ç‹€æ…‹ç®¡ç†ï¼ŒToolCallManager å°ˆæ³¨æ–¼ç´”ç²¹çš„åŸ·è¡Œé‚è¼¯ã€‚é€éåœ¨ execute() æ–¹æ³•ä¸­ç›´æ¥å‚³å…¥ approvalsï¼Œæˆ‘å€‘å¯¦ç¾äº†çœŸæ­£çš„é—œæ³¨é»åˆ†é›¢ï¼ŒåŒæ™‚å¤§å¹…ç°¡åŒ–äº†æ•´å€‹ç³»çµ±çš„è¤‡é›œåº¦ã€‚




Retry
å« ToolCallRunner æœƒä¸æœƒæ¯”è¼ƒé©åˆï¼Ÿæˆ–æ˜¯æœ‰å…¶ä»–å»ºè­°çš„åç¨±
å› ç‚ºä»–å·²ç¶“ stateless

Edit

è©•ä¼°å‘½åé¸é …ï¼Œèªç‚º ToolCallRunner æœ€é©åˆ stateless é¡åˆ¥
9s




ä½ çš„ç›´è¦ºå¾ˆæº–ç¢ºï¼ ToolCallRunner ç¢ºå¯¦æ¯” ToolCallManager æ›´é©åˆã€‚

å‘½ååˆ†æ
ç‚ºä»€éº¼ ToolCallRunner æ›´å¥½
typescript
// Manager æš—ç¤ºç‹€æ…‹ç®¡ç†è·è²¬
class ToolCallManager {
  // è®“äººæœŸå¾…çœ‹åˆ°é€™äº›...
  private state: SomeState
  public getState() { }
  public setState() { }
  public reset() { }
}

// Runner æš—ç¤ºç´”ç²¹çš„åŸ·è¡Œè·è²¬  
class ToolCallRunner {
  // ç¬¦åˆæœŸå¾…ï¼šstateless çš„åŸ·è¡Œå¼•æ“
  async execute(input) { /* ç´”ç²¹åŸ·è¡Œé‚è¼¯ */ }
}
å…¶ä»–å€™é¸åç¨±æ¯”è¼ƒ
ToolCallRunner â­ (æ¨è–¦)
âœ… æ¸…æ¥šè¡¨é”ã€Œé‹è¡Œ/åŸ·è¡Œã€çš„è·è²¬
âœ… æš—ç¤º stateless çš„ç‰¹æ€§
âœ… ç°¡æ½”ç›´è§€
ToolCallExecutor
âœ… æ­£å¼ï¼Œæ˜ç¢ºè¡¨é”åŸ·è¡Œè·è²¬
âœ… åœ¨å¾ˆå¤šç³»çµ±ä¸­æ˜¯å¸¸è¦‹æ¨¡å¼
â“ ç¨å¾®æ­£å¼ï¼Œä½†ä¹Ÿå¾ˆå¥½
ToolCallEngine
âœ… æš—ç¤ºè™•ç†å¼•æ“çš„æ¦‚å¿µ
âŒ å¯èƒ½æš—ç¤ºå…§éƒ¨æœ‰è¤‡é›œç‹€æ…‹æ©Ÿåˆ¶
ToolCallProcessor
âœ… è¡¨é”è™•ç†çš„è·è²¬
âŒ æ²’æœ‰ Runner é‚£éº¼ç›´è§€
ToolCallService
âŒ å¤ªé€šç”¨ï¼Œæ²’æœ‰æ˜ç¢ºè¡¨é” stateless ç‰¹æ€§
æœ€çµ‚å»ºè­°
æˆ‘æŠ•ç¥¨çµ¦ ToolCallRunnerï¼ŒåŸå› ï¼š

1. èªç¾©ç²¾ç¢º
typescript
// åç¨±ç›´æ¥åæ˜ åŠŸèƒ½
const runner = new ToolCallRunner(toolRegistry)
const result = await runner.execute(toolCalls, approvals)
// ä¸€çœ‹å°±çŸ¥é“ï¼šé€™æ˜¯å€‹åŸ·è¡Œå·¥å…·çš„ runner
2. ç¬¦åˆ Stateless ç‰¹æ€§
typescript
// Runner é€šå¸¸æš—ç¤ºç„¡ç‹€æ…‹çš„åŸ·è¡Œå–®å…ƒ
class ToolCallRunner {
  // ä¸æœƒè®“äººæœŸå¾…çœ‹åˆ°ç‹€æ…‹ç®¡ç†æ–¹æ³•
  async execute() { /* ç´”ç²¹åŸ·è¡Œé‚è¼¯ */ }
}
3. èˆ‡ç³»çµ±å‘½åä¿æŒå’Œè«§
typescript
// èˆ‡å…¶ä»–é¡åçš„é¢¨æ ¼ä¸€è‡´
ChatSession    // ç‹€æ…‹ç®¡ç†
TaskService    // æ¥­å‹™é‚è¼¯  
ToolCallRunner // ç´”ç²¹åŸ·è¡Œ
4. æœªä¾†æ“´å±•å‹å¥½
typescript
// å¦‚æœæœªä¾†éœ€è¦ä¸åŒçš„åŸ·è¡Œç­–ç•¥
class ToolCallRunner { }
class ParallelToolCallRunner extends ToolCallRunner { }
class SequentialToolCallRunner extends ToolCallRunner { }
æ‰€ä»¥æœ€çµ‚æ¶æ§‹æœƒæ˜¯ï¼š

typescript
class ChatSession {
  private toolCallRunner: ToolCallRunner
  
  async runTurn(input: TurnInput) {
    // ...
    const result = await this.toolCallRunner.execute(toolCalls, approvals)
    // ...
  }
}

class ToolCallRunner {
  async execute(
    toolCalls: ToolCall[], 
    approvals?: ToolCallApproval[]
  ): Promise<ToolExecutionResult> {
    // ç´”ç²¹çš„åŸ·è¡Œé‚è¼¯
  }
}
ToolCallRunner ç¢ºå¯¦æ˜¯æœ€ä½³é¸æ“‡ï¼ğŸ‘




Retry
éåº¦è¤‡é›œçš„ç‹€æ…‹æ©Ÿ 7 å€‹ç‹€æ…‹ï¼švalidating | scheduled | executing | success | error | cancelled | awaiting_approval 100+ è¡Œçš„è¤‡é›œç‹€æ…‹è½‰æ›é‚è¼¯
æˆ‘æ˜¯è¦ºå¾—å¯ä»¥ä¿ç•™åŸæœ¬çš„ç‹€æ…‹ï¼Œé€™äº›ç‹€æ…‹ä¹Ÿç¢ºå¯¦æœ‰æ„ç¾©
100+ è¡Œçš„è¤‡é›œç‹€æ…‹è½‰æ›é‚è¼¯ -> ä¸»è¦æ˜¯é€™å€‹å•é¡Œï¼Œç‚ºä»€éº¼éœ€è¦è¤‡é›œç‹€æ…‹è½‰æ›ï¼Ÿç‚ºä»€éº¼ä»–æœƒæå¾—è¤‡é›œï¼Ÿæœ‰æ²’æœ‰ç°¡ä¾¿çš„åšæ³•ï¼Ÿ

Edit

è§£æè¤‡é›œç‹€æ…‹è½‰æ›ï¼Œæå‡ºç°¡åŒ–è¨­è¨ˆæ–¹æ¡ˆ
17s




ä½ èªªå¾—å¾ˆå°ï¼ç‹€æ…‹æœ¬èº«æ˜¯æœ‰æ„ç¾©çš„ï¼Œå•é¡Œåœ¨æ–¼ç‹€æ…‹è½‰æ›çš„å¯¦ç¾æ–¹å¼éæ–¼è¤‡é›œã€‚

ç‚ºä»€éº¼ç›®å‰çš„ç‹€æ…‹è½‰æ›é€™éº¼è¤‡é›œï¼Ÿ
å•é¡Œæ ¹æºï¼šDiscriminated Union è¨­è¨ˆ
typescript
// æ¯å€‹ç‹€æ…‹éƒ½æ˜¯ä¸åŒçš„ TypeScript type
type ValidatingToolCall = {
  status: "validating"
  request: ToolCallRequestInfo
  tool: Tool
  startTime?: number
}

type ExecutingToolCall = {
  status: "executing"  
  request: ToolCallRequestInfo
  tool: Tool
  liveOutput?: string    // åªæœ‰åŸ·è¡Œç‹€æ…‹æ‰æœ‰
  startTime?: number
}

type SuccessfulToolCall = {
  status: "success"
  request: ToolCallRequestInfo
  tool: Tool
  response: ToolCallResponseInfo  // åªæœ‰æˆåŠŸç‹€æ…‹æ‰æœ‰
  durationMs?: number
}

// æ›´å¤šç‹€æ…‹...
è¤‡é›œç‹€æ…‹è½‰æ›çš„åŸå› 
typescript
// ç‹€æ…‹è½‰æ› = é‡æ–°æ§‹é€ æ•´å€‹å°è±¡
private setStatusInternal(...) {
  switch (newStatus) {
    case "success":
      return {
        request: currentCall.request,
        tool: toolInstance,
        status: "success",
        response: auxiliaryData,           // æ–°å¢å­—æ®µ
        durationMs: extraData?.durationMs, // æ–°å¢å­—æ®µ
        outcome,                           // ä¿ç•™å­—æ®µ
      } as SuccessfulToolCall             // å¼·åˆ¶è½‰å‹

    case "executing":
      return {
        request: currentCall.request,
        tool: toolInstance, 
        status: "executing",
        liveOutput: "",                    // æ–°å¢å­—æ®µ
        startTime: existingStartTime,      // ä¿ç•™å­—æ®µ
      } as ExecutingToolCall
      
    // æ¯å€‹ç‹€æ…‹éƒ½è¦é‡æ–°æ§‹é€ ...
  }
}
å•é¡Œï¼š

æ¯æ¬¡ç‹€æ…‹è½‰æ›éƒ½è¦é‡æ–°æ§‹é€ æ•´å€‹å°è±¡
éœ€è¦æ±ºå®šå“ªäº›å­—æ®µä¿ç•™ã€å“ªäº›æ–°å¢
TypeScript é¡å‹è½‰æ›è¤‡é›œ
å®¹æ˜“éºæ¼å­—æ®µæˆ–é¡å‹éŒ¯èª¤
ç°¡åŒ–æ–¹æ¡ˆï¼šçµ±ä¸€ ToolCall çµæ§‹
ä¿ç•™ç‹€æ…‹ï¼Œç°¡åŒ–è½‰æ›
typescript
// çµ±ä¸€çš„ ToolCall çµæ§‹ï¼Œæ‰€æœ‰å­—æ®µéƒ½æ˜¯ optional
interface ToolCall {
  // åŸºæœ¬ä¿¡æ¯
  id: string
  request: ToolCallRequestInfo
  tool: Tool
  
  // ç‹€æ…‹
  status: "validating" | "scheduled" | "executing" | "success" | "error" | "cancelled" | "awaiting_approval"
  
  // æ™‚é–“è¿½è¹¤
  startTime?: number
  endTime?: number
  durationMs?: number
  
  // åŸ·è¡Œç›¸é—œ
  liveOutput?: string
  response?: ToolCallResponseInfo
  error?: string
  
  // ç¢ºèªç›¸é—œ
  confirmationDetails?: ToolCallConfirmationDetails
  outcome?: ToolConfirmationOutcome
}
æ¥µç°¡çš„ç‹€æ…‹è½‰æ›
typescript
class ToolCallRunner {
  private updateToolCallStatus(
    toolCall: ToolCall, 
    newStatus: ToolCall["status"],
    updates?: Partial<ToolCall>
  ): ToolCall {
    // ç°¡å–®çš„å°è±¡æ›´æ–°ï¼Œä¸éœ€è¦é‡æ§‹
    return {
      ...toolCall,
      status: newStatus,
      updatedAt: new Date(),
      ...updates  // åªæ›´æ–°éœ€è¦çš„å­—æ®µ
    }
  }
  
  // ä½¿ç”¨ç¯„ä¾‹
  async executeTool(toolCall: ToolCall): Promise<ToolCall> {
    // é–‹å§‹åŸ·è¡Œ
    let updated = this.updateToolCallStatus(toolCall, "executing", {
      startTime: Date.now()
    })
    
    try {
      const result = await toolCall.tool.execute(toolCall.request.args)
      
      // åŸ·è¡ŒæˆåŠŸ
      return this.updateToolCallStatus(updated, "success", {
        response: { result, error: null },
        endTime: Date.now(),
        durationMs: Date.now() - updated.startTime!
      })
      
    } catch (error) {
      // åŸ·è¡Œå¤±æ•—
      return this.updateToolCallStatus(updated, "error", {
        error: error.message,
        endTime: Date.now(),
        durationMs: Date.now() - updated.startTime!
      })
    }
  }
}
ç‹€æ…‹æª¢æŸ¥è®Šå¾—ç°¡å–®
typescript
// ä¸éœ€è¦è¤‡é›œçš„ type guard
function isExecuting(toolCall: ToolCall): boolean {
  return toolCall.status === "executing"
}

function hasLiveOutput(toolCall: ToolCall): boolean {
  return !!toolCall.liveOutput
}

function isCompleted(toolCall: ToolCall): boolean {
  return ["success", "error", "cancelled"].includes(toolCall.status)
}
ä¿ç•™ç‹€æ…‹èªç¾©çš„å¥½è™•
1. æ¸…æ¥šçš„åŸ·è¡Œéšæ®µ
typescript
// ç‹€æ…‹è½‰æ›æµç¨‹ä¾ç„¶æ¸…æ¥š
"validating" â†’ "scheduled" â†’ "executing" â†’ "success"
            â†˜             â†—              â†˜ "error"  
              "awaiting_approval"         â†˜ "cancelled"
2. è±å¯Œçš„ç‹€æ…‹ä¿¡æ¯
typescript
// æ¯å€‹ç‹€æ…‹éƒ½æœ‰æ˜ç¢ºçš„èªç¾©
switch (toolCall.status) {
  case "validating":
    showSpinner("Checking permissions...")
    break
  case "awaiting_approval": 
    showApprovalDialog(toolCall.confirmationDetails)
    break
  case "executing":
    showProgress(toolCall.liveOutput)
    break
  case "success":
    showResult(toolCall.response)
    break
}
3. æ›´å¥½çš„ UI/UX
typescript
// ä¸åŒç‹€æ…‹å¯ä»¥æœ‰ä¸åŒçš„è¦–è¦ºå‘ˆç¾
const getStatusColor = (status: ToolCall["status"]) => {
  switch (status) {
    case "validating": return "yellow"
    case "scheduled": return "blue" 
    case "executing": return "orange"
    case "success": return "green"
    case "error": return "red"
    case "cancelled": return "gray"
    case "awaiting_approval": return "purple"
  }
}
ç¸½çµ
ä¿ç•™ 7 å€‹ç‹€æ…‹ï¼Œä½†ç°¡åŒ–ç‹€æ…‹è½‰æ›é‚è¼¯ï¼š

çµ±ä¸€ ToolCall çµæ§‹ - é¿å… discriminated union çš„è¤‡é›œæ€§
ç°¡å–®çš„ç‹€æ…‹æ›´æ–° - åªä¿®æ”¹éœ€è¦çš„å­—æ®µï¼Œä¸é‡æ§‹æ•´å€‹å°è±¡
ä¿ç•™ç‹€æ…‹èªç¾© - æ¯å€‹ç‹€æ…‹ä¾ç„¶æœ‰æ¸…æ¥šçš„æ„ç¾©
æ¸›å°‘ TypeScript è¤‡é›œåº¦ - ä¸éœ€è¦è¤‡é›œçš„é¡å‹è½‰æ›
é€™æ¨£æ—¢ä¿æŒäº†ç‹€æ…‹çš„è¡¨é”èƒ½åŠ›ï¼Œåˆå¤§å¹…ç°¡åŒ–äº†å¯¦ç¾è¤‡é›œåº¦ï¼




Retry
é€™æ¨£é‚„éœ€è¦ updateToolCallStatus å—ï¼Ÿ
ç‚ºä»€éº¼ä¸ç›´æ¥ return { args, ...rest }

Edit

é‡æ–°è©•ä¼°æ–¹æ³•ï¼Œç›´æ¥ä½¿ç”¨ spread operator æ›´ç°¡æ½”
7s







ä½ èªªå¾—å®Œå…¨æ­£ç¢ºï¼ æˆ‘éåº¦è¨­è¨ˆäº†ã€‚æ—¢ç„¶å·²ç¶“çµ±ä¸€äº† ToolCall çµæ§‹ï¼Œç›´æ¥ç”¨ spread operator æ›´ç°¡æ½”ç›´è§€ã€‚

ç›´æ¥æ›´æ–° vs Helper æ–¹æ³•
ç›´æ¥æ›´æ–°ï¼ˆæ¨è–¦ï¼‰
typescript
async executeTool(toolCall: ToolCall): Promise<ToolCall> {
  // é–‹å§‹åŸ·è¡Œ
  const executing = {
    ...toolCall,
    status: "executing" as const,
    startTime: Date.now()
  }
  
  try {
    const result = await toolCall.tool.execute(toolCall.request.args)
    
    // åŸ·è¡ŒæˆåŠŸ
    return {
      ...executing,
      status: "success" as const,
      response: { result, error: null },
      endTime: Date.now(),
      durationMs: Date.now() - executing.startTime!
    }
    
  } catch (error) {
    // åŸ·è¡Œå¤±æ•—  
    return {
      ...executing,
      status: "error" as const,
      error: error.message,
      endTime: Date.now(),
      durationMs: Date.now() - executing.startTime!
    }
  }
}
ç‚ºä»€éº¼ç›´æ¥æ›´æ–°æ›´å¥½
æ›´ç°¡æ½”ç›´è§€
typescript
// ç›´æ¥çœ‹åˆ°åœ¨æ›´æ–°ä»€éº¼
return {
  ...toolCall,
  status: "success",
  response: result
}

// vs éœ€è¦å»ç†è§£ helper æ–¹æ³•åšäº†ä»€éº¼
return this.updateToolCallStatus(toolCall, "success", { response: result })
æ¸›å°‘æŠ½è±¡å±¤ç´š
typescript
// æ²’æœ‰ä¸å¿…è¦çš„ä¸­é–“å±¤
const updated = { ...toolCall, status: "executing" }

// vs å¤šäº†ä¸€å±¤æŠ½è±¡
const updated = this.updateToolCallStatus(toolCall, "executing")
TypeScript é¡å‹æ¨æ–·æ›´å¥½
typescript
// TypeScript ç›´æ¥çŸ¥é“æ–°å°è±¡çš„é¡å‹
const success = {
  ...toolCall,
  status: "success" as const,
  response: result
}
// success.status çš„é¡å‹æ˜¯ "success"

// vs helper æ–¹æ³•å¯èƒ½éœ€è¦é¡å¤–çš„é¡å‹è¨»è§£
ä»€éº¼æ™‚å€™æ‰éœ€è¦ Helper æ–¹æ³•ï¼Ÿ
åªåœ¨æœ‰å…±é€šé‚è¼¯æ™‚æ‰è€ƒæ…®ï¼š

typescript
// å¦‚æœæ¯æ¬¡ç‹€æ…‹æ›´æ–°éƒ½éœ€è¦åšé€™äº›äº‹æƒ…
private updateToolCallStatus(toolCall: ToolCall, newStatus: string, updates: Partial<ToolCall>) {
  return {
    ...toolCall,
    ...updates,
    status: newStatus,
    updatedAt: new Date(),           // çµ±ä¸€æ™‚é–“æˆ³
    version: toolCall.version + 1    // ç‰ˆæœ¬æ§åˆ¶
  }
}

// æˆ–è€…éœ€è¦ç‹€æ…‹è½‰æ›é©—è­‰
private updateToolCallStatus(toolCall: ToolCall, newStatus: string, updates: Partial<ToolCall>) {
  this.validateStateTransition(toolCall.status, newStatus)  // é©—è­‰åˆæ³•æ€§
  this.logStateChange(toolCall.id, toolCall.status, newStatus)  // æ—¥èªŒè¨˜éŒ„
  
  return { ...toolCall, ...updates, status: newStatus }
}
ä½†åœ¨æˆ‘å€‘çš„å ´æ™¯ä¸­ï¼Œæ²’æœ‰é€™äº›éœ€æ±‚ï¼Œæ‰€ä»¥ç›´æ¥ç”¨ spread operator å°±æ˜¯æœ€ä½³é¸æ“‡ï¼

ç°¡åŒ–å¾Œçš„å®Œæ•´ç¯„ä¾‹
typescript
class ToolCallRunner {
  async execute(toolCalls: ToolCall[], approvals?: ToolCallApproval[]): Promise<ToolExecutionResult> {
    const executed: ToolResult[] = []
    const stillNeedsApproval: ToolCall[] = []
    const failed: ToolError[] = []
    
    for (const toolCall of toolCalls) {
      // ç›´æ¥æ›´æ–°ç‹€æ…‹ï¼Œç°¡æ½”æ˜ç­
      const validating = {
        ...toolCall,
        status: "validating" as const,
        startTime: Date.now()
      }
      
      // æª¢æŸ¥ approval é‚è¼¯...
      
      const executing = {
        ...validating,
        status: "executing" as const
      }
      
      try {
        const result = await toolCall.tool.execute(toolCall.request.args)
        
        const success = {
          ...executing,
          status: "success" as const,
          response: { result, error: null },
          endTime: Date.now(),
          durationMs: Date.now() - executing.startTime!
        }
        
        executed.push({ toolCallId: success.id, result })
        
      } catch (error) {
        const failed = {
          ...executing,
          status: "error" as const,
          error: error.message,
          endTime: Date.now(),
          durationMs: Date.now() - executing.startTime!
        }
        
        failed.push({ toolCallId: failed.id, error })
      }
    }
    
    return { executed, stillNeedsApproval, failed }
  }
}
çµè«–ï¼šä½ çš„ç›´è¦ºå¾ˆå°ï¼Œç›´æ¥ç”¨ { ...toolCall, status: "new_status" } å°±å¤ äº†ï¼ç°¡å–®ã€ç›´è§€ã€é«˜æ•ˆã€‚ğŸ‘




Retry
okay è«‹å†é‡æ–°æ•´ç†ä¸€æ¬¡ä»¥ä¸Šæ•´å€‹è¨è«–

Edit



Analyzed tool-call system and proposed redesign strategy.
3s




Tool Call ç³»çµ±é‡æ§‹è¨­è¨ˆç¸½çµ
ç•¶å‰ç³»çµ±åˆ†æ
Tool Call ç³»çµ±é‹ä½œæµç¨‹
åˆå§‹åŒ–èˆ‡é©—è­‰ï¼šå‰µå»º ToolCall å°è±¡ï¼ˆvalidating ç‹€æ…‹ï¼‰
æ¬Šé™æª¢æŸ¥ï¼šæ ¹æ“š ApprovalMode å’Œå·¥å…·å±éšªç­‰ç´šæ±ºå®šæ˜¯å¦éœ€è¦ç”¨æˆ¶ç¢ºèª
ä¸¦è¡ŒåŸ·è¡Œï¼šæ‰€æœ‰ scheduled ç‹€æ…‹çš„å·¥å…·ä¸¦è¡ŒåŸ·è¡Œ
ç‹€æ…‹ç®¡ç†ï¼šè¤‡é›œçš„ 7 ç‹€æ…‹ç‹€æ…‹æ©Ÿç®¡ç†
MCP æ”¯æ´æ¶æ§‹
é€é ToolRegistry.registerMCPServer() è¨»å†Š MCP ä¼ºæœå™¨
å‰µå»º MCP å·¥å…·åŒ…è£å™¨ï¼Œçµ±ä¸€ Tool ä»‹é¢
ç›®å‰æ˜¯ mock å¯¦ç¾ï¼Œä½†æ¶æ§‹å·²æº–å‚™å¥½çœŸå¯¦æ•´åˆ
æ ¸å¿ƒå•é¡Œè­˜åˆ¥
1. é›™é‡ç‹€æ…‹ç®¡ç†
typescript
// ç‹€æ…‹åˆ†æ•£åœ¨å…©å€‹åœ°æ–¹
class ChatSession {
  messages: ChatMessage[] = []
  status: ChatStatus = 'idle'
}

class ToolCallScheduler {  // â† é€™æ˜¯ stateful çš„ï¼
  private toolCalls: Map<string, ToolCall[]> = new Map()
  private pendingConfirmations: Map<string, WaitingToolCall> = new Map()
}
2. æ¶æ§‹ä¸ä¸€è‡´
Chat Engine: ç´” event-drivenï¼Œæ¸…çˆ½çš„ session ç®¡ç†
Tool Call: æ··åˆ callback + eventï¼Œè¤‡é›œçš„ç‹€æ…‹ç®¡ç†
3. éåº¦è¤‡é›œçš„ç‹€æ…‹è½‰æ›
typescript
// 100+ è¡Œçš„è¤‡é›œé‚è¼¯
private setStatusInternal(messageId, targetCallId, newStatus, auxiliaryData?, extraData?) {
  switch (newStatus) {
    case "success":
      return {
        request: currentCall.request,
        tool: toolInstance,
        status: "success",
        response: auxiliaryData,           // éœ€è¦é‡æ–°æ§‹é€ æ•´å€‹å°è±¡
        durationMs: extraData?.durationMs,
        outcome,
      } as SuccessfulToolCall             // è¤‡é›œçš„é¡å‹è½‰æ›
    // ... æ›´å¤šç‹€æ…‹è™•ç†
  }
}
å•é¡Œæ ¹æºï¼šä½¿ç”¨ Discriminated Union è¨­è¨ˆï¼Œæ¯æ¬¡ç‹€æ…‹è½‰æ›éƒ½è¦é‡æ–°æ§‹é€ æ•´å€‹å°è±¡ã€‚

é‡æ§‹è¨­è¨ˆæ–¹æ¡ˆ
æ ¸å¿ƒè¨­è¨ˆæ±ºç­–
ChatSession çµ±ä¸€ç‹€æ…‹ç®¡ç† - æ‰€æœ‰ç‹€æ…‹éƒ½ç”± ChatSession ç®¡ç†
ToolCallRunner ä½œç‚º Pure Function - å®Œå…¨ stateless çš„åŸ·è¡Œå¼•æ“
ç›´æ¥æ–¹æ³•èª¿ç”¨ - é¿å… event-driven çš„éåº¦è¤‡é›œæ€§
ç°¡åŒ–ç‹€æ…‹è½‰æ› - çµ±ä¸€ ToolCall çµæ§‹ï¼Œç›´æ¥æ›´æ–°å­—æ®µ
æ–°æ¶æ§‹è¨­è¨ˆ
1. ToolCallRunner (Stateless Pure Function)
typescript
interface ToolCallApproval {
  toolCallId: string
  approved: boolean
  timestamp?: Date
}

interface ToolExecutionResult {
  executed: ToolResult[]           // é€™æ¬¡åŸ·è¡Œå®Œæˆçš„å·¥å…·
  stillNeedsApproval: ToolCall[]   // ä»éœ€è¦ç”¨æˆ¶ç¢ºèªçš„å·¥å…·  
  failed: ToolError[]              // åŸ·è¡Œå¤±æ•—çš„å·¥å…·
}

class ToolCallRunner {
  // å®Œå…¨ stateless çš„ pure function
  async execute(
    toolCalls: ToolCall[], 
    approvals?: ToolCallApproval[]  // é—œéµå‰µæ–°ï¼šç›´æ¥å‚³å…¥ approvals
  ): Promise<ToolExecutionResult> {
    
    const approvalMap = new Map(
      approvals?.map(a => [a.toolCallId, a.approved]) || []
    )
    
    const executed: ToolResult[] = []
    const stillNeedsApproval: ToolCall[] = []
    const failed: ToolError[] = []
    
    for (const toolCall of toolCalls) {
      // æª¢æŸ¥approvalç‹€æ…‹
      const hasApproval = approvalMap.has(toolCall.id)
      const isApproved = approvalMap.get(toolCall.id)
      
      if (hasApproval && !isApproved) {
        continue // ç”¨æˆ¶æ‹’çµ•ï¼Œè·³é
      }
      
      const tool = this.toolRegistry.getTool(toolCall.name)
      const needsConfirmation = await tool.needsConfirmation(toolCall.arguments)
      
      if (needsConfirmation && !hasApproval) {
        stillNeedsApproval.push(toolCall)
        continue
      }
      
      // åŸ·è¡Œå·¥å…·
      const executing = {
        ...toolCall,
        status: "executing" as const,
        startTime: Date.now()
      }
      
      try {
        const result = await tool.execute(toolCall.arguments)
        
        const success = {
          ...executing,
          status: "success" as const,
          response: { result, error: null },
          endTime: Date.now(),
          durationMs: Date.now() - executing.startTime!
        }
        
        executed.push({ toolCallId: success.id, result })
        
      } catch (error) {
        const errorResult = {
          ...executing,
          status: "error" as const,
          error: error.message,
          endTime: Date.now(),
          durationMs: Date.now() - executing.startTime!
        }
        
        failed.push({ toolCallId: errorResult.id, error })
      }
    }
    
    return { executed, stillNeedsApproval, failed }
  }
}
2. ChatSession (çµ±ä¸€ç‹€æ…‹ç®¡ç†)
typescript
class ChatSession {
  // åŸæœ‰ç‹€æ…‹
  messages: ChatMessage[] = []
  status: ChatStatus = 'idle'
  
  // å·¥å…·èª¿ç”¨ç‹€æ…‹ï¼ˆçµ±ä¸€ç®¡ç†ï¼‰
  private pendingToolCalls: ToolCall[] = []
  private toolCallApprovals: ToolCallApproval[] = []
  private completedToolResults: ToolResult[] = []
  
  async runTurn(input: TurnInput): Promise<ConversationResult> {
    const aiResponse = await this.generateModelResponse()
    
    if (aiResponse.hasToolCalls) {
      // å„²å­˜æ–°çš„å·¥å…·èª¿ç”¨
      this.pendingToolCalls = aiResponse.toolCalls
      
      // ä¸€æ¬¡æ€§åŸ·è¡Œï¼Œå‚³å…¥ç¾æœ‰çš„approvals
      const result = await this.toolCallRunner.execute(
        this.pendingToolCalls,
        this.toolCallApprovals
      )
      
      return this.handleToolResult(result)
    }
    
    return { status: 'complete', content: aiResponse.content }
  }
  
  private handleToolResult(result: ToolExecutionResult): ConversationResult {
    // æ›´æ–°ç‹€æ…‹
    this.completedToolResults.push(...result.executed)
    this.pendingToolCalls = result.stillNeedsApproval
    
    if (result.stillNeedsApproval.length > 0) {
      this.status = 'waiting_confirmation'
      return {
        status: 'waiting_confirmation',
        toolCalls: result.stillNeedsApproval.map(tc => ({
          id: tc.id,
          name: tc.name,
          arguments: tc.arguments,
          needsConfirmation: true
        }))
      }
    }
    
    // æ‰€æœ‰å·¥å…·éƒ½åŸ·è¡Œå®Œæˆ
    this.status = 'idle'
    return this.continueAfterToolExecution()
  }
  
  async confirmToolCall(toolCallId: string, approved: boolean): Promise<ConversationResult> {
    // 1. æ›´æ–°approvalç‹€æ…‹
    this.toolCallApprovals.push({
      toolCallId,
      approved,
      timestamp: new Date()
    })
    
    // 2. é‡æ–°åŸ·è¡Œæ‰€æœ‰pendingçš„å·¥å…·èª¿ç”¨ï¼ˆçµ±ä¸€é‚è¼¯ï¼ï¼‰
    const result = await this.toolCallRunner.execute(
      this.pendingToolCalls,
      this.toolCallApprovals
    )
    
    // 3. è™•ç†çµæœ
    return this.handleToolResult(result)
  }
}
3. ç°¡åŒ–çš„ç‹€æ…‹ç®¡ç†
çµ±ä¸€ ToolCall çµæ§‹
typescript
// çµ±ä¸€çµæ§‹ï¼Œé¿å… Discriminated Union çš„è¤‡é›œæ€§
interface ToolCall {
  // åŸºæœ¬ä¿¡æ¯
  id: string
  request: ToolCallRequestInfo
  tool: Tool
  
  // ç‹€æ…‹ï¼ˆä¿ç•™åŸæœ‰çš„ 7 å€‹ç‹€æ…‹ï¼Œå®ƒå€‘æœ‰æ„ç¾©ï¼‰
  status: "validating" | "scheduled" | "executing" | "success" | "error" | "cancelled" | "awaiting_approval"
  
  // æ™‚é–“è¿½è¹¤
  startTime?: number
  endTime?: number
  durationMs?: number
  
  // åŸ·è¡Œç›¸é—œ
  liveOutput?: string
  response?: ToolCallResponseInfo
  error?: string
  
  // ç¢ºèªç›¸é—œ
  confirmationDetails?: ToolCallConfirmationDetails
  outcome?: ToolConfirmationOutcome
}
æ¥µç°¡çš„ç‹€æ…‹è½‰æ›
typescript
// ä¸éœ€è¦è¤‡é›œçš„ helper æ–¹æ³•ï¼Œç›´æ¥ç”¨ spread operator
const executing = {
  ...toolCall,
  status: "executing" as const,
  startTime: Date.now()
}

const success = {
  ...executing,
  status: "success" as const,
  response: { result, error: null },
  endTime: Date.now(),
  durationMs: Date.now() - executing.startTime!
}
è¨­è¨ˆæ±ºç­–çš„é—œéµæ´å¯Ÿ
1. ç‚ºä»€éº¼é¸æ“‡ç›´æ¥èª¿ç”¨è€Œé Event-Drivenï¼Ÿ
typescript
// Event æ–¹å¼ - éåº¦è¤‡é›œ
await toolManager.execute(toolCalls)
this.eventBus.subscribe("TOOL_COMPLETED", ...)
this.eventBus.subscribe("TOOL_NEEDS_APPROVAL", ...)

// ç›´æ¥æ–¹å¼ - ç°¡å–®ç›´è§€
const result = await toolRunner.execute(toolCalls, approvals)
if (result.stillNeedsApproval.length > 0) {
  return { status: 'waiting_confirmation', toolCalls: result.stillNeedsApproval }
}
ç†ç”±ï¼šChatSession â†” ToolRunner æ˜¯ä¸€å°ä¸€çš„ç·Šå¯†åˆä½œé—œä¿‚ï¼Œä¸æ˜¯é¬†è€¦åˆçš„ç™¼å¸ƒè¨‚é–±å ´æ™¯ã€‚

2. ç‚ºä»€éº¼åœ¨ execute() ä¸­ç›´æ¥å‚³å…¥ approvalsï¼Ÿ
typescript
// çµ±ä¸€é‚è¼¯ï¼šåˆæ¬¡åŸ·è¡Œå’Œç¢ºèªå¾ŒåŸ·è¡Œéƒ½æ˜¯åŒä¸€å€‹æ–¹æ³•
await this.toolCallRunner.execute(toolCalls, approvals)
å„ªå‹¢ï¼š

ChatSession ç´”ç²¹åšç‹€æ…‹ç®¡ç†
ToolCallRunner ç´”ç²¹åšåŸ·è¡Œé‚è¼¯
çœŸæ­£çš„ Pure Function - ç›¸åŒè¼¸å…¥ï¼Œç›¸åŒè¼¸å‡º
3. ç‚ºä»€éº¼å‘½åç‚º ToolCallRunnerï¼Ÿ
Manager æš—ç¤ºç‹€æ…‹ç®¡ç†è·è²¬
Runner æš—ç¤º stateless çš„åŸ·è¡Œå¼•æ“
èªç¾©ç²¾ç¢ºï¼Œç¬¦åˆå¯¦éš›åŠŸèƒ½
é‡æ§‹å„ªå‹¢ç¸½çµ
1. æ¶æ§‹ä¸€è‡´æ€§
ç§»é™¤é›™é‡ç‹€æ…‹ç®¡ç†
èˆ‡ ChatEngine ä¿æŒä¸€è‡´çš„è¨­è¨ˆæ¨¡å¼
2. Pure Function çš„å¨åŠ›
typescript
// å®Œå…¨å¯é æ¸¬
const result1 = await runner.execute(toolCalls, approvals)
const result2 = await runner.execute(toolCalls, approvals) 
// result1 === result2
3. ç‹€æ…‹ç®¡ç†ç°¡åŒ–
typescript
// åªéœ€è¦ä¸‰å€‹ç°¡å–®çš„é™£åˆ—
private pendingToolCalls: ToolCall[] = []
private toolCallApprovals: ToolCallApproval[] = []  
private completedToolResults: ToolResult[] = []
4. æ¸¬è©¦å‹å¥½
typescript
// æ¸¬è©¦è®Šå¾—ç°¡å–®
const runner = new ToolCallRunner(mockRegistry)
const result = await runner.execute(
  [{ id: '1', name: 'test', arguments: {} }],
  [{ toolCallId: '1', approved: true }]
)
expect(result.executed).toHaveLength(1)
5. è‡ªç„¶çš„æŒä¹…åŒ–
typescript
// ChatSession åºåˆ—åŒ–åŒ…å«æ‰€æœ‰ç‹€æ…‹
toJSON(): SerializableChat {
  return {
    // åŸæœ‰å­—æ®µ...
    pendingToolCalls: this.pendingToolCalls,
    toolCallApprovals: this.toolCallApprovals,
    completedToolResults: this.completedToolResults
  }
}
å…¶ä»–æ”¹é€²
èˆ‡ AI SDK é¡å‹çµ±ä¸€ - ä½¿ç”¨ AI SDK æ¨™æº–é¡å‹ï¼Œåªåœ¨éœ€è¦æ™‚æ“´å±•
ä¿ç•™ MCP æ¶æ§‹ - ç¶­æŒç¾æœ‰ MCP æ•´åˆè¨­è¨ˆ
ä¿ç•™ 7 å€‹ç‹€æ…‹ - ç‹€æ…‹æœ¬èº«æœ‰æ„ç¾©ï¼Œåªç°¡åŒ–è½‰æ›é‚è¼¯
çµè«–
é€™å€‹é‡æ§‹çš„æ ¸å¿ƒæ˜¯ï¼šChatSession å°ˆæ³¨æ–¼ç‹€æ…‹ç®¡ç†ï¼ŒToolCallRunner å°ˆæ³¨æ–¼ç´”ç²¹çš„åŸ·è¡Œé‚è¼¯ã€‚é€éåœ¨ execute() æ–¹æ³•ä¸­ç›´æ¥å‚³å…¥ approvalsï¼Œå¯¦ç¾äº†çœŸæ­£çš„é—œæ³¨é»åˆ†é›¢ï¼ŒåŒæ™‚å¤§å¹…ç°¡åŒ–äº†ç³»çµ±è¤‡é›œåº¦ã€‚

é—œéµå‰µæ–°ï¼šç‹€æ…‹ç®¡ç†æ­¸ä¸€åŒ– + Pure Function åŸ·è¡Œå¼•æ“ + çµ±ä¸€çš„èª¿ç”¨æ¨¡å¼




Retry
è«‹å†æª¢æŸ¥ç¢ºèª

class ToolCallRunner {
  // å®Œå…¨ stateless çš„ pure function
  async execute(

å¦‚æœå®Œå…¨ statelessï¼Œé‚£å®Œå…¨å¯ä»¥ç¨ç«‹æˆä¸€å€‹ executeToolCall function
ä½†æˆ‘è¨˜å¾— tool call æ˜¯è¦æ­é… registry
æ‰€ä»¥é‚„æ˜¯éœ€è¦ class

private handleToolResult(result: ToolExecutionResult): ConversationResult {

å› ç‚º ui æ˜¯åŸºæ–¼ chat session event streamä¾†æ›´æ–°ï¼Œtool call æ‡‰è©²ä¹Ÿéœ€è¦ï¼Ÿ
å¦‚æœæ˜¯è¦åš tool call execution streamï¼Œæ„Ÿè¦ºéœ€è¦æ˜¯  toolCallRunner.execute(â€¦, eventBus)
ä½†è€ƒæ…®åˆ° MVP ï¼Œç›´æ¥ç­‰å¾… tool call åŸ·è¡Œå®Œæˆå¾Œå†è¡Œå¾ session.eventBus.emit(â€¦) æˆ–è¨±ç°¡å–®ä¸€äº›ï¼Ÿ
UI å°±æ˜¯é€é session status (ä¾‹å¦‚ â€˜tool_call_execution_startâ€™)ä¾†é¡¯ç¤ºtool callæ­£åœ¨åŸ·è¡Œä¸­

async confirmToolCall(toolCallId: string, approved: boolean): Promise<ConversationResult> {

approval -> æ”¹æˆ confirmation
tool call confirmation æ‡‰è©²æœ‰3ç¨®ï¼Œyes, yes always, no
ä¸€æ—¦ yes alwaysï¼Œä¸‹æ¬¡åŒæ¨£çš„ tool å°±ä¸ç”¨å†è©¢å•ï¼Œå¯ä»¥ç›´æ¥åŸ·è¡Œ

æ‰€ä»¥æˆ‘è¦ºå¾—éœ€è¦ä¿å­˜ toolCallConfirmations åœ¨ sessionï¼Œæ¯æ¬¡çš„ tool call confirm éƒ½æ˜¯ by sessionï¼Œé global -> æœªä¾†ä¹Ÿè¨±å¯ä»¥è€ƒæ…® user settings æˆ–æ˜¯ project settings å¢åŠ  tool call settingsï¼Œé¿å…æ¯æ¬¡æ–°çš„ session éƒ½è¦é‡å•ï¼Œä½†ç›®å‰ä¸è€ƒæ…®

æˆ‘åˆæƒ³äº†ä¸€ä¸‹ï¼Œæˆ‘è¦ºå¾—å°±ç®—æ˜¯åœ¨ toolRunner çµ¦ eventBus ä¹Ÿå¯ä»¥
æˆ‘æƒ³åˆ°çš„æ˜¯å¦‚æœæœ‰ n å€‹ tool callsï¼Œä½¿ç”¨è€…å¯èƒ½æœƒéœ€è¦çŸ¥é“ç¾åœ¨æ­£åœ¨åŸ·è¡Œç¬¬å¹¾å€‹ï¼Œå¦‚æœæ˜¯éƒ½æŠŠ tool calls ä¸Ÿçµ¦toolCallRunnerï¼Œé‚£åªæœ‰ toolCallRunner æœƒçŸ¥é“ç¾åœ¨åŸ·è¡Œåˆ°ç¬¬å¹¾å€‹ï¼ˆåŒ…å«åŸ·è¡Œçš„çµæœï¼‰ï¼Œsession åªæœ‰åœ¨å…¨éƒ¨çš„ toolCalls éƒ½åŸ·è¡Œå®Œæˆå¾Œæ‰æœƒå¾—åˆ°çµæœ
è¦åŠæ™‚åæ‡‰é€™ç¨®ç‹€æ…‹ï¼Œæˆ–è¨±é‚„æ˜¯éœ€è¦ eventBusï¼Œå°±ç•¶æˆæ˜¯ tool-call-eventï¼Ÿ

Edit

Refined tool call design with event stream and confirmation strategy.
11s



ä½ çš„æª¢æŸ¥éå¸¸ä»”ç´°ï¼é€™äº›éƒ½æ˜¯é‡è¦çš„è¨­è¨ˆè€ƒé‡ï¼Œè®“æˆ‘é‡æ–°å¯©è¦–å’Œèª¿æ•´ã€‚

1. ToolCallRunner ç¢ºå¯¦éœ€è¦ Class
typescript
// ä½ èªªå¾—å°ï¼Œéœ€è¦ registryï¼Œæ‰€ä»¥å¿…é ˆæ˜¯ class
class ToolCallRunner {
  constructor(private toolRegistry: ToolRegistry) {}
  
  async execute(...) {
    // éœ€è¦ this.toolRegistry.getTool(...)
  }
}

// ä¸èƒ½æ˜¯ç¨ç«‹ functionï¼Œå› ç‚ºéœ€è¦ä¾è³´
// function executeToolCalls(...) {} // âŒ ç¼ºå°‘ registry
2. Tool Call Execution Stream çš„é‡æ–°æ€è€ƒ
ä½ èªªå¾—å¾ˆå°ï¼ç”¨æˆ¶é«”é©—éœ€è¦å³æ™‚åé¥‹ï¼š

å•é¡Œåˆ†æ
typescript
// ç¾åœ¨çš„è¨­è¨ˆå•é¡Œ
async execute(toolCalls: ToolCall[]): Promise<ToolExecutionResult> {
  // åŸ·è¡Œ n å€‹å·¥å…·...
  // Session åªæœ‰åœ¨å…¨éƒ¨å®Œæˆå¾Œæ‰çŸ¥é“çµæœ
  // ç”¨æˆ¶çœ‹ä¸åˆ°ä¸­é–“é€²åº¦ï¼
}
å…©ç¨®è§£æ±ºæ–¹æ¡ˆæ¯”è¼ƒ
æ–¹æ¡ˆ Aï¼šMVP ç°¡å–®ç‰ˆæœ¬
typescript
class ChatSession {
  async runTurn(input: TurnInput): Promise<ConversationResult> {
    if (aiResponse.hasToolCalls) {
      // ç™¼é€é–‹å§‹äº‹ä»¶
      this.status = 'processing_tools'
      await this.eventBus.emit({
        kind: 'ChatUpdatedEvent',
        updateType: 'STATUS_CHANGED',
        update: { status: 'processing_tools' }
      })
      
      // ç­‰å¾…å…¨éƒ¨å®Œæˆ
      const result = await this.toolCallRunner.execute(toolCalls, approvals)
      
      // ç™¼é€å®Œæˆäº‹ä»¶
      return this.handleToolResult(result)
    }
  }
}
æ–¹æ¡ˆ Bï¼šEvent Stream ç‰ˆæœ¬ â­ (æ¨è–¦)
typescript
class ToolCallRunner {
  constructor(
    private toolRegistry: ToolRegistry,
    private eventBus: IEventBus  // æ¥æ”¶ eventBus
  ) {}
  
  async execute(
    toolCalls: ToolCall[], 
    approvals?: ToolCallApproval[],
    context?: { chatId: string, messageId: string }
  ): Promise<ToolExecutionResult> {
    
    for (let i = 0; i < toolCalls.length; i++) {
      const toolCall = toolCalls[i]
      
      // ç™¼é€é–‹å§‹åŸ·è¡Œäº‹ä»¶
      await this.eventBus.emit({
        kind: 'ToolCallStarted',
        chatId: context?.chatId,
        toolCallId: toolCall.id,
        toolName: toolCall.name,
        progress: { current: i + 1, total: toolCalls.length }
      })
      
      // åŸ·è¡Œå·¥å…·...
      
      // ç™¼é€å®Œæˆäº‹ä»¶
      await this.eventBus.emit({
        kind: 'ToolCallCompleted',
        chatId: context?.chatId,
        toolCallId: toolCall.id,
        result: success ? result : error
      })
    }
  }
}
æˆ‘å‚¾å‘æ–¹æ¡ˆ Bï¼Œå› ç‚ºï¼š

æ›´å¥½çš„ç”¨æˆ¶é«”é©—ï¼ˆå³æ™‚é€²åº¦ï¼‰
æœªä¾†æ“´å±•æ€§æ›´å¥½
èˆ‡ç³»çµ± event-driven æ¶æ§‹ä¸€è‡´
3. Confirmation è¨­è¨ˆæ”¹é€²
ä¸‰ç¨®ç¢ºèªé¸é …
typescript
type ConfirmationOutcome = "yes" | "yes_always" | "no"

interface ToolCallConfirmation {
  toolCallId: string
  outcome: ConfirmationOutcome
  timestamp: Date
}

interface AlwaysAllowRule {
  toolName: string
  argsPattern?: Record<string, any>  // å¯é¸ï¼šç‰¹å®šåƒæ•¸æ¨¡å¼
  createdAt: Date
}
Session ç´šåˆ¥çš„ Confirmation ç®¡ç†
typescript
class ChatSession {
  // Confirmation ç‹€æ…‹ï¼ˆper sessionï¼‰
  private toolCallConfirmations: ToolCallConfirmation[] = []
  private alwaysAllowRules: AlwaysAllowRule[] = []  // "yes always" çš„è¨˜éŒ„
  
  async confirmToolCall(
    toolCallId: string, 
    outcome: ConfirmationOutcome
  ): Promise<ConversationResult> {
    
    // è¨˜éŒ„ç¢ºèªæ±ºå®š
    this.toolCallConfirmations.push({
      toolCallId,
      outcome,
      timestamp: new Date()
    })
    
    // å¦‚æœæ˜¯ "yes always"ï¼Œå»ºç«‹è¦å‰‡
    if (outcome === "yes_always") {
      const toolCall = this.pendingToolCalls.find(tc => tc.id === toolCallId)
      if (toolCall) {
        this.alwaysAllowRules.push({
          toolName: toolCall.name,
          createdAt: new Date()
        })
      }
    }
    
    // é‡æ–°åŸ·è¡Œ
    const result = await this.toolCallRunner.execute(
      this.pendingToolCalls,
      this.buildApprovals()  // åŒ…å« always allow è¦å‰‡
    )
    
    return this.handleToolResult(result)
  }
  
  private buildApprovals(): ToolCallApproval[] {
    const approvals: ToolCallApproval[] = []
    
    // åŠ å…¥æ˜ç¢ºçš„ç¢ºèªæ±ºå®š
    for (const confirmation of this.toolCallConfirmations) {
      if (confirmation.outcome === "yes" || confirmation.outcome === "yes_always") {
        approvals.push({
          toolCallId: confirmation.toolCallId,
          approved: true
        })
      }
    }
    
    // åŠ å…¥ "always allow" è¦å‰‡çš„è‡ªå‹•æ‰¹å‡†
    for (const toolCall of this.pendingToolCalls) {
      const hasAlwaysRule = this.alwaysAllowRules.some(rule => 
        rule.toolName === toolCall.name
      )
      
      if (hasAlwaysRule && !approvals.find(a => a.toolCallId === toolCall.id)) {
        approvals.push({
          toolCallId: toolCall.id,
          approved: true
        })
      }
    }
    
    return approvals
  }
}
4. é‡æ–°æ•´åˆçš„å®Œæ•´è¨­è¨ˆ
ToolCallRunner with EventBus
typescript
class ToolCallRunner {
  constructor(
    private toolRegistry: ToolRegistry,
    private eventBus: IEventBus
  ) {}
  
  async execute(
    toolCalls: ToolCall[], 
    approvals: ToolCallApproval[] = [],
    context: { chatId: string, messageId: string }
  ): Promise<ToolExecutionResult> {
    
    const executed: ToolResult[] = []
    const stillNeedsApproval: ToolCall[] = []
    const failed: ToolError[] = []
    
    const approvalMap = new Map(approvals.map(a => [a.toolCallId, a.approved]))
    
    for (let i = 0; i < toolCalls.length; i++) {
      const toolCall = toolCalls[i]
      
      // ç™¼é€é€²åº¦äº‹ä»¶
      await this.eventBus.emit({
        kind: 'ToolCallProgress',
        chatId: context.chatId,
        progress: { current: i + 1, total: toolCalls.length },
        currentTool: { id: toolCall.id, name: toolCall.name }
      })
      
      // æª¢æŸ¥æ˜¯å¦éœ€è¦ç¢ºèª
      const hasApproval = approvalMap.has(toolCall.id)
      const isApproved = approvalMap.get(toolCall.id)
      
      if (hasApproval && !isApproved) {
        continue
      }
      
      const tool = this.toolRegistry.getTool(toolCall.name)
      const needsConfirmation = await tool.needsConfirmation(toolCall.arguments)
      
      if (needsConfirmation && !hasApproval) {
        stillNeedsApproval.push(toolCall)
        continue
      }
      
      // åŸ·è¡Œå·¥å…·
      try {
        await this.eventBus.emit({
          kind: 'ToolCallStarted',
          chatId: context.chatId,
          toolCallId: toolCall.id,
          toolName: toolCall.name
        })
        
        const result = await tool.execute(toolCall.arguments)
        
        await this.eventBus.emit({
          kind: 'ToolCallCompleted',
          chatId: context.chatId,
          toolCallId: toolCall.id,
          result: { success: true, data: result }
        })
        
        executed.push({ toolCallId: toolCall.id, result })
        
      } catch (error) {
        await this.eventBus.emit({
          kind: 'ToolCallCompleted',
          chatId: context.chatId,
          toolCallId: toolCall.id,
          result: { success: false, error: error.message }
        })
        
        failed.push({ toolCallId: toolCall.id, error })
      }
    }
    
    return { executed, stillNeedsApproval, failed }
  }
}
ChatSession çš„ç°¡åŒ–
typescript
class ChatSession {
  async runTurn(input: TurnInput): Promise<ConversationResult> {
    const aiResponse = await this.generateModelResponse()
    
    if (aiResponse.hasToolCalls) {
      this.pendingToolCalls = aiResponse.toolCalls
      
      // å‚³å…¥ context å’Œ approvals
      const result = await this.toolCallRunner.execute(
        this.pendingToolCalls,
        this.buildApprovals(),
        { chatId: this.id, messageId: this.getCurrentMessageId() }
      )
      
      return this.handleToolResult(result)
    }
    
    return { status: 'complete', content: aiResponse.content }
  }
}
ç¸½çµ
é‡æ–°æª¢æŸ¥å¾Œçš„é—œéµèª¿æ•´ï¼š

ToolCallRunner ä¿æŒ class - éœ€è¦ registry ä¾è³´
EventBus æ•´åˆ - æä¾›å³æ™‚é€²åº¦åé¥‹ï¼Œæ›´å¥½çš„ UX
ä¸‰ç¨®ç¢ºèªé¸é … - yes/yes_always/noï¼Œsession ç´šåˆ¥ç®¡ç†
Always Allow è¦å‰‡ - é¿å…é‡è¤‡è©¢å•ç›¸åŒå·¥å…·
é€™æ¨£æ—¢ä¿æŒäº†æ¶æ§‹ç°¡æ½”ï¼Œåˆæä¾›äº†è‰¯å¥½çš„ç”¨æˆ¶é«”é©—ï¼




Retry
const result = await this.toolCallRunner.execute( this.pendingToolCalls, this.buildApprovals() *// åŒ…å« always allow *è¦å‰‡ )

ç›´æ¥ toolCallRunner.execute( pendingToolCalls, toolCallConfirmations) 
äº¤çµ¦ toolCallRunner ä¾†å»è™•ç† confirmations ä¸æ˜¯æ›´å¥½ï¼Ÿ SRP

private alwaysAllowRules: AlwaysAllowRule[] = [] *// "yes always" *çš„è¨˜éŒ„

æ”¹åï¼Œåƒæ˜¯* toolAlwaysAllowed ? æˆ‘çŸ¥é“é€™å€‹åå­—ä¸å¥½ï¼Œæˆ‘å¸Œæœ›æ‰¾äº‹è®“äººçŸ¥é“é€™æ˜¯ tool call confirmation ç›¸é—œï¼Œè«‹å»ºè­°å¹¾å€‹
é€™å€‹æ‡‰è©²å¯ä»¥é€é  *toolCallRunner.execute -> return *toolAlwaysAllowed *
ç¸½ä¹‹å°±æ˜¯æŠŠ* tool çš„éƒ¨åˆ†æ”¾åœ¨ tool call ï¼Œsession *åªè² è²¬å„²å­˜

Edit

Refined tool call confirmation strategy with clear responsibilities
12s






ä½ èªªå¾—å®Œå…¨æ­£ç¢ºï¼ é€™å…©å€‹è§€é»éƒ½å¾ˆé‡è¦ï¼Œè®“æˆ‘é‡æ–°è¨­è¨ˆã€‚

1. SRPï¼šè·è²¬åˆ†é›¢é‡æ–°è¨­è¨ˆ
ChatSession åªè² è²¬å„²å­˜ï¼Œä¸è™•ç†é‚è¼¯
typescript
class ChatSession {
  // ç´”å„²å­˜ï¼Œä¸è™•ç†é‚è¼¯
  private toolCallConfirmations: ToolCallConfirmation[] = []
  private toolApprovalPolicies: ToolApprovalPolicy[] = []  // æ–°å‘½å
  
  async runTurn(input: TurnInput): Promise<ConversationResult> {
    if (aiResponse.hasToolCalls) {
      this.pendingToolCalls = aiResponse.toolCalls
      
      // ç›´æ¥å‚³åŸå§‹æ•¸æ“šï¼Œè®“ runner è™•ç†é‚è¼¯
      const result = await this.toolCallRunner.execute(
        this.pendingToolCalls,
        this.toolCallConfirmations,    // åŸå§‹ç¢ºèªè¨˜éŒ„
        this.toolApprovalPolicies,     // åŸå§‹ always allow è¦å‰‡
        { chatId: this.id, messageId: this.getCurrentMessageId() }
      )
      
      // å„²å­˜ runner è¿”å›çš„æ–°è¦å‰‡
      if (result.newApprovalPolicies.length > 0) {
        this.toolApprovalPolicies.push(...result.newApprovalPolicies)
      }
      
      return this.handleToolResult(result)
    }
    
    return { status: 'complete', content: aiResponse.content }
  }
  
  // ç¢ºèªé‚è¼¯ä¹Ÿç°¡åŒ–äº†
  async confirmToolCall(
    toolCallId: string, 
    outcome: ConfirmationOutcome
  ): Promise<ConversationResult> {
    
    // åªè² è²¬å„²å­˜ç¢ºèªè¨˜éŒ„
    this.toolCallConfirmations.push({
      toolCallId,
      outcome,
      timestamp: new Date()
    })
    
    // é‡æ–°åŸ·è¡Œï¼Œè®“ runner è™•ç†é‚è¼¯
    const result = await this.toolCallRunner.execute(
      this.pendingToolCalls,
      this.toolCallConfirmations,    // åŒ…å«æ–°çš„ç¢ºèª
      this.toolApprovalPolicies,
      { chatId: this.id, messageId: this.getCurrentMessageId() }
    )
    
    // å„²å­˜æ–°çš„ policies
    if (result.newApprovalPolicies.length > 0) {
      this.toolApprovalPolicies.push(...result.newApprovalPolicies)
    }
    
    return this.handleToolResult(result)
  }
}
ToolCallRunner è™•ç†æ‰€æœ‰é‚è¼¯
typescript
interface ToolExecutionResult {
  executed: ToolResult[]
  stillNeedsApproval: ToolCall[]
  failed: ToolError[]
  newApprovalPolicies: ToolApprovalPolicy[]  // æ–°å¢ï¼šè¿”å›æ–°çš„ always allow è¦å‰‡
}

class ToolCallRunner {
  async execute(
    toolCalls: ToolCall[],
    confirmations: ToolCallConfirmation[],
    approvalPolicies: ToolApprovalPolicy[],
    context: { chatId: string, messageId: string }
  ): Promise<ToolExecutionResult> {
    
    const executed: ToolResult[] = []
    const stillNeedsApproval: ToolCall[] = []
    const failed: ToolError[] = []
    const newApprovalPolicies: ToolApprovalPolicy[] = []
    
    // Runner è™•ç†ç¢ºèªé‚è¼¯
    const approvalMap = this.buildApprovalMap(confirmations, approvalPolicies)
    
    for (const toolCall of toolCalls) {
      const approvalStatus = this.checkApprovalStatus(toolCall, approvalMap, approvalPolicies)
      
      if (approvalStatus.needsConfirmation) {
        stillNeedsApproval.push(toolCall)
        continue
      }
      
      if (!approvalStatus.approved) {
        continue // è¢«æ‹’çµ•
      }
      
      // å¦‚æœæ˜¯æ–°çš„ "yes always"ï¼Œå»ºç«‹æ–°è¦å‰‡
      if (approvalStatus.createPolicy) {
        newApprovalPolicies.push({
          toolName: toolCall.name,
          createdAt: new Date()
        })
      }
      
      // åŸ·è¡Œå·¥å…·...
    }
    
    return { executed, stillNeedsApproval, failed, newApprovalPolicies }
  }
  
  private buildApprovalMap(
    confirmations: ToolCallConfirmation[],
    policies: ToolApprovalPolicy[]
  ): Map<string, ApprovalStatus> {
    // è™•ç†ç¢ºèªé‚è¼¯çš„è¤‡é›œæ€§
    const map = new Map<string, ApprovalStatus>()
    
    // è™•ç†æ˜ç¢ºçš„ç¢ºèªè¨˜éŒ„
    for (const confirmation of confirmations) {
      map.set(confirmation.toolCallId, {
        approved: confirmation.outcome === "yes" || confirmation.outcome === "yes_always",
        createPolicy: confirmation.outcome === "yes_always"
      })
    }
    
    return map
  }
  
  private checkApprovalStatus(
    toolCall: ToolCall,
    approvalMap: Map<string, ApprovalStatus>,
    policies: ToolApprovalPolicy[]
  ): { approved: boolean, needsConfirmation: boolean, createPolicy: boolean } {
    
    // æª¢æŸ¥æ˜¯å¦æœ‰æ˜ç¢ºç¢ºèª
    const explicitApproval = approvalMap.get(toolCall.id)
    if (explicitApproval) {
      return {
        approved: explicitApproval.approved,
        needsConfirmation: false,
        createPolicy: explicitApproval.createPolicy
      }
    }
    
    // æª¢æŸ¥æ˜¯å¦ç¬¦åˆ always allow è¦å‰‡
    const hasPolicy = policies.some(policy => policy.toolName === toolCall.name)
    if (hasPolicy) {
      return {
        approved: true,
        needsConfirmation: false,
        createPolicy: false
      }
    }
    
    // éœ€è¦ç¢ºèª
    return {
      approved: false,
      needsConfirmation: true,
      createPolicy: false
    }
  }
}
2. å‘½åå»ºè­°
å°æ–¼ alwaysAllowRulesï¼Œæˆ‘å»ºè­°å¹¾å€‹é¸é …ï¼š

æ¨è–¦é¸é …
toolApprovalPolicies â­ (æœ€æ¨è–¦)
æ¸…æ¥šè¡¨é”æ˜¯å·¥å…·æ‰¹å‡†æ”¿ç­–
èˆ‡ tool call confirmation ç›¸é—œ
å°ˆæ¥­ä¸”æ˜ç¢º
toolConfirmationPolicies
ç›´æ¥è¡¨é”èˆ‡ confirmation çš„é—œä¿‚
ç¨å¾®é•·ä¸€é»ä½†å¾ˆæ¸…æ¥š
autoApprovalRules
å¼·èª¿è‡ªå‹•æ‰¹å‡†çš„ç‰¹æ€§
ç°¡æ½”æ˜“æ‡‚
å°æ‡‰çš„é¡å‹å®šç¾©
typescript
interface ToolApprovalPolicy {
  toolName: string
  argsPattern?: Record<string, any>  // æœªä¾†å¯æ“´å±•ï¼šç‰¹å®šåƒæ•¸æ¨¡å¼
  createdAt: Date
  description?: string  // å¯é¸ï¼šç”¨æˆ¶ç‚ºä»€éº¼é¸æ“‡ always allow
}

type ConfirmationOutcome = "yes" | "yes_always" | "no"

interface ToolCallConfirmation {
  toolCallId: string
  outcome: ConfirmationOutcome
  timestamp: Date
}
3. å®Œæ•´çš„è·è²¬åˆ†é›¢
typescript
// ChatSessionï¼šç´”ç²¹çš„ç‹€æ…‹å®¹å™¨
class ChatSession {
  // å„²å­˜ç‹€æ…‹
  private toolCallConfirmations: ToolCallConfirmation[] = []
  private toolApprovalPolicies: ToolApprovalPolicy[] = []
  
  // ä¸è™•ç†é‚è¼¯ï¼Œåªå‚³éå’Œå„²å­˜
}

// ToolCallRunnerï¼šç´”ç²¹çš„é‚è¼¯è™•ç†å™¨
class ToolCallRunner {
  // è™•ç†æ‰€æœ‰ confirmation å’Œ approval é‚è¼¯
  // æ±ºå®šå“ªäº›å·¥å…·éœ€è¦ç¢ºèªï¼Œå“ªäº›å¯ä»¥è‡ªå‹•åŸ·è¡Œ
  // å»ºç«‹æ–°çš„ approval policies
}
é€™æ¨£çš„è¨­è¨ˆå®Œç¾éµå¾ª SRPï¼š

ChatSessionï¼šå°è©±ç‹€æ…‹ç®¡ç†
ToolCallRunnerï¼šå·¥å…·åŸ·è¡Œé‚è¼¯
ä½ çš„å»ºè­°è®“æ¶æ§‹è®Šå¾—æ›´æ¸…æ™°ã€æ›´ç¬¦åˆè¨­è¨ˆåŸå‰‡ï¼ğŸ‘




Retry







