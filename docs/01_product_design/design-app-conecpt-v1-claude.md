# AI輔助工作流程應用程式設計 Q&A

## Q1: 這個應用程式主要是要解決什麼問題？

這個應用程式主要解決的是現代工作者常面臨的幾個痛點：

我們常常很懶、沒時間或忙不過來，需要某種外部力量「推著我們前進」，而不是靠自己「主動」去做。想像一下，當你完成一項工作後，有時候會陷入一種「下一步該做什麼」的迷茫或惰性。就像我設計完首頁、強化了mock資料後，可能會有點懶得繼續實現下一步。

在這種時候，我希望AI能主動推動我，例如當我給了一些產出後，AI就自動開始進行下一步，不用等我指示。我可以先休息放空，回來後再看AI的成果。

特別是在AI輔助開發過程中，我們面臨幾個具體問題：

- Github Copilot的效果有時不如專屬應用
- 開發過程中需要不斷從一個階段性節點重新開始對話
- 檔案管理非常麻煩，常需要來回複製貼上
- 難以針對AI生成的結果給予具體評論

在UI開發過程中，與AI的互動通常需要多次來回修改，工作基本上需要分階段完成—每次達成一小部分，確認後再開始新的對話繼續完善。想一口氣完成通常效果不佳。

關鍵問題是：能否將這樣的互動過程記錄下來並流程化，這樣相同的工作流程未來就不需要我再次一步步指引？

## Q2: 「Push not pull」的設計核心是什麼？

「Push not pull」的核心理念源自於人性的本質—我們都很懶！我希望設計一個AI秘書，我只需要「給予工作指示」和「確認」，而工作的實際進行則盡量交給AI自己執行。

想像一下，每天工作的第一步就是看儀表板，查看AI需要我處理的審核和批准事項，確認後AI就繼續自動執行。當有新工作時，我只需提供基本指示，AI與我確認細節後，就由它來執行。

這就是「推動」(push)而非「拉動」(pull)的概念—不是我主動去找工作做，而是系統主動推送工作給我，僅需要我在關鍵節點進行確認或決策。這種設計模式能大幅減輕認知負擔，讓使用者只需專注於重要決策，而不必主動思考「下一步該做什麼」。

## Q3: 這個系統與一般AI agent系統有什麼不同？

我們的系統與一般AI agent系統主要有兩個核心差異：

### 1. 半自動 vs 全自動

目前市面上的agent系統大多追求全自動化操作，讓AI自行完成所有任務。但我認為在許多情況下，半自動模式反而更符合實際工作流程。

舉例來說，在開發時遇到問題，我詢問AI後得到解決方案，我會自然希望按照這個解法去實作。這種半自動的方式讓我能在關鍵節點保持控制權，同時釋放我處理繁瑣細節的精力。

### 2. 工作流可追蹤、修改、重複利用

有些工作具有高度重複性，例如翻譯新聞和製作摘要。當我優化出一個有效的prompt後，我只需更換input並重新執行整個工作流程，就能獲得想要的結果。

在我使用AI的過程中，不斷調整prompt以獲得更好結果是很常見的。因此我希望能夠重複利用這些已經優化好的工作流，同時在過程中繼續微調（例如修改prompt）。在這種情況下，全自動agent不符合我的需求，我更需要一個可高度編輯的「AI工作流編輯器」。

簡而言之，我們的系統是：

- AI工作流編輯器＋執行器 <-> 任務執行進度管理

這樣的設計不僅能實現工作流自動化，還能保留足夠的彈性和使用者控制。

## Q4: 「下一步」功能是如何運作的？

「下一步」功能解決了一個常見心理現象：當我們完成一項工作後，常常會陷入「不知道下一步做什麼」或「懶得做下一步」的狀態。畢竟，剛完成一項工作已經消耗了不少精力，很自然地想稍微休息一下。

這時，如果有一個簡單的 [Next] 按鈕，只需點擊就能讓AI幫我規劃下一步並自動執行，這會大大降低繼續工作的心理門檻。

具體運作方式是：

1. 完成當前工作後，點擊「下一步」按鈕
2. AI自動分析當前進度，建議下一步行動
3. 使用者確認或調整建議
4. AI開始自動執行下一步工作
5. 在AI執行期間，使用者可以休息
6. AI完成後，使用者回來檢查結果，必要時調整

舉例來說，當我在程式開發中遇到問題，與AI討論並得到解決方案後，點擊「下一步」，AI可能會建議基於這個討論進行設計。我確認後，AI自動進行設計，接著AI可能會建議下一步實作程式碼，然後進行測試，最後提交代碼等。

在AI自動執行的時間裡，我可以休息或處理其他事務。等AI產出結果後，我再回來檢查成果是否符合需求。如果不滿意，只需修改prompt或input即可，這比從零開始簡單得多。關鍵理念是「先讓它跑起來」！

這種方式既提高了工作效率，又減輕了使用者的認知負擔，讓整個流程更加順暢自然。

## Q5: Workspace/Project的基本架構是怎樣的？

Workspace（或Project）是我們系統的最高層級組織單位，用於管理相關的任務集合。讓我以一個具體例子說明其檔案結構：

```
/(Workspace) Develop a startup app
├── /(task) [Run Button] commit event channel code
├── /(task) [Run Button] 對 event channel code 寫測試
├── /(task) [Run Button] 依照設計實作 event channel code
├── /(task) [Run Button] 參考討論串重新設計 event channel
│   ├── (entrypoint) chat_01_v1.json  // Prompt: 「參考 #artifact_討論串整理.md 重新設計 event channel」
│   └── artifact_設計.v1.md  // AI生成的設計文件
└── /(task) [Run Button] Events 在前後端傳輸時碰到 websocket 斷連情況要如何做
    ├── (entrypoint) chat_01_v1.json  // Prompt: 「events 在前後端傳輸時碰到 websocket 斷連情況要如何做？」
    └── artifact_討論串整理.v1.md  // AI生成的討論整理
```

每個Task都是一個資料夾，包含chat檔案和AI生成的成果（artifact）。這種結構有幾個特點：

1. **階層化組織**：Task可以有子Task，形成樹狀結構
2. **版本控制**：使用v1、v2等來區分同一檔案的不同版本
3. **統一執行介面**：每個Task都有執行按鈕，可以重新執行該Task
4. **關聯性**：Task之間可以相互引用，例如用`#artifact_檔名`的形式

關於檔案命名，我們遵循以下規則：

- Chat檔案：`chat_{id_or_title}.v{n}.json`
- Artifact檔案：`artifact_{title}.v{n}.{extension}`

透過這種結構，我們可以清晰地管理複雜專案中的多個相關任務，並保留執行歷史和結果。

## Q6: Task和Chat的定義和關係是什麼？

### Task定義

Task是我們系統中的核心組織單位，代表一個具體的工作項目。從技術角度看：

1. Task是一個資料夾，內部必定包含一個`task.json`檔案，用於識別和定義這個Task
2. Task可以包含多個Chat檔案、AI生成的Artifact以及其他檔案
3. Task可以包含子Task（即SubTask），形成階層結構

Task與Claude平台的Project有些相似之處，但更加靈活：

- Task ←→ Claude project
- Task files ←→ Claude project files
- Task chats ←→ Claude project chats
- Task's subtasks ←→ Claude沒有這個概念
- Run a task ←→ Claude沒有這個功能

### Chat定義

Chat是使用者與AI之間的對話，是Task中的基本交互單位：

1. Chat基本上就是AI與使用者之間的問答交流
2. Chat可以使用不同的AI模型
3. Chat中可以包含function calling等進階功能
4. 一個Chat檔案命名形式為`chat_{id_or_title}.v{n}.json`

### Task與Chat的關係

1. 一個Task可以包含多個Chat，代表與該任務相關的不同對話
2. 第一個Chat通常是任務的入口點（entrypoint），定義了任務的基本內容
3. 後續Chat可以是任務的延續，也可以只是與任務相關的問答
4. 當執行Task時，系統會按照特定規則執行其中的Chat

例如，一個「對掃描檔做OCR」的Task可能包含多個依序執行的Chat：

- Chat 1: 對p1.jpg做OCR
- Chat 2: 對p2.jpg做OCR
- Chat 3: 對p3.jpg做OCR

又如，一個「依照設計寫程式碼」的Task可能有：

- Chat 1: 「現在已經完成：(empty)，請寫：code1」
- Chat 2: 「現在已經完成：code1，請寫：code2」
- Chat 3: 「現在已經完成：code1, code2，請寫：code3」

這種結構非常適合需要分階段完成的複雜任務。

## Q7: Task knowledge是如何管理的？

Task knowledge是指任務執行所需參考的檔案和知識。我們設計了幾種管理方式：

### 方案1：專用知識資料夾

在Task資料夾中建立一個專用的`/task_knowledge`子資料夾，裡面的所有檔案自動被視為Task knowledge，並在執行時注入到對話中：

```
/task
├── /task_knowledge
│   ├── a.py, b.py
│   └── task_instruction.md
```

### 方案2：UI標記方式

使用UI界面來標記和控制哪些檔案應被納入knowledge範圍，提供更直觀的管理方式。

### 方案3：注入式引用（目前偏好）

使用者可以直接在prompt中使用`#檔案路徑`的方式注入需要的檔案，這樣更靈活，例如：

```
Chat 1v1：「#a.py #…/event/test 請參考 tests，為某class 寫 test」
Chat 1v2：「#a.py #b.py #…/event/test 請參考 tests，為某class 寫 test」
```

這提供了更直觀的方式進行快速調整，不需要反覆操作知識庫設置。

### XML標記方式

更進階的做法是預設將Task資料夾（不含子階層）的所有檔案納入`<task_knowledge>`，並允許使用者通過XML方式修改：

```
<task_knowledge>
#p1.jpg #p2.jpg
#*.jpg (或直接用萬用字元)
</task_knowledge>

<task_instruction> … </task_instruction>

請對 p1.jpg 做 OCR
```

Task knowledge也會記錄在`task.json`中，當使用者在prompt中調整Task knowledge時，系統會自動更新記錄。

這種靈活的知識管理方式讓使用者能夠精確控制AI在任務執行過程中可以訪問的資訊，提高工作效率。

## Q8: 如何執行Task和Task chain？

### 單一Task執行

執行Task的基本方式是點擊Task旁邊的[Run Button]。當執行一個Task時，系統會：

1. 加載Task中的entrypoint chat（通常是第一個chat）
2. 執行chat中的prompt，產生AI回應
3. 產生的結果會存為artifact或更新chat歷史

### Task Chain執行

當多個Task形成依賴關係時（一個Task的輸出是另一個Task的輸入），就自然形成了Task Chain。例如在「Develop a startup app」的例子中，各個Task按照順序依賴前一個Task的輸出。

在MVP階段，我們採用較為簡單的方式處理Task Chain：

- **Naive做法**：完全不管依賴關係，使用者手動決定執行哪個Task
- **未來計劃**：基於依賴分析建立執行圖（run graph），可選擇性地自動執行下一個相關Task

### 特殊執行情況

**當Task下包含子Task時的執行順序：**

```
/task 1
├── /task 2
└── /task 3
```

最簡單的做法是按照資料夾排序依序執行子Task（task2 → task3）。

**當Task下同時有Chat和子Task時：**

```
/task 1
├── /task 2
├── /task 3
└── chat.json
```

初步的做法是先執行parent，再執行children，例如task1 → task2 → task3。

這些執行規則設計的理念是盡量保持直觀性，讓使用者能夠預期系統的行為。未來版本中，我們可能會提供更細緻的控制機制，讓使用者自定義執行流程。

## Q9: Chat panel的UI設計是怎樣的？

Chat panel是使用者與AI交互的主要界面。下面是它的基本設計：

```
(Text Input Box)
--------------------------------------------------|
|                                                  |
|                                                  |
|                                                  |
--------------------------------------------------|
[Agent] [New Task] [Claude 3.7] [Submit]
```

各元素說明：

- **Text Input Box**：使用者輸入prompt的區域
- **[Agent]**：可選按鈕，開啟Agent模式
- **[New Task]**：選擇此按鈕後，提交的對話會創建新的task資料夾
- **[Claude 3.7]**：模型選擇器，可以切換不同的AI模型
- **[Submit]**：提交按鈕

當使用者在workspace explorer中點擊一個`chat.json`檔案時，系統會：

1. 在中間欄開啟chat panel
2. 顯示該chat的對話記錄
3. 底部提供輸入框，可以繼續與AI對話

而當點擊[New Chat]按鈕時：

1. Chat panel會開啟新的對話
2. 使用者輸入prompt並送出
3. 若沒有選擇[New Task]，系統會創建一個新的chat.json
4. 若選擇了[New Task]，則創建新的task資料夾，包含當前的chat

這種設計兼顧了簡潔性和功能性，讓使用者能夠在統一的界面中管理不同類型的對話和任務。

## Q10: 有哪些對話模式？

我們系統支援多種對話模式，以適應不同的工作場景：

### 1. 基本輪流模式 (Basic Rotation)

最常見的對話形式：user → ai → user → ai...

這是最直觀的交流方式，適合一般問答、討論和簡單任務。

### 2. Agent模式 (MVP初期不考慮)

更複雜的自動化模式：
user (初始任務) → (ai (planner) → ai (action) → system →) 循環直到觸發終止條件

終止條件可能是：

- Agent判斷任務已完成
- 達到最大預算限制
- 達到最大迭代次數

Agent模式適合需要多步驟自動化執行的複雜任務。

### 3. Group Chat模式 (MVP不考慮)

多AI協作模式：user → ai 1 → ai 2 → ai 3 → user...

這本質上仍是輪流模式的一種變體，但引入了多個不同角色的AI，適合需要不同專業視角的複雜問題。

不同的對話模式適用於不同的工作場景。在系統初期版本中，我們優先實現基本輪流模式，確保核心功能穩定可靠，然後再逐步添加更複雜的模式。

## Q11: 如何實現半自動化工作流程？

我們的系統提供多種方式來實現半自動化工作流程，讓AI與使用者協作完成任務：

### 全自動方法：使用Agent

例如：使用者輸入「對掃描檔做OCR (開啟agent)」→ AI分析、提出計劃、循環執行、輸出檔案

這種方式使用者只需提供高階指令，其餘工作完全交給AI自動完成。

### 半自動方法：

#### 1. 「下一步」功能

- 使用者：「對p1.jpg做OCR」
- AI產出結果
- 使用者點擊[下一步]
- AI自動生成下個task建議
- 使用者確認執行

這種方式使用者保留對每個階段的控制權，但不需要自己思考下一步是什麼。

#### 2. AI建議Prompt (MVP初期不考慮)

- 使用者：「對p1.jpg做OCR」
- AI產出結果
- 使用者點擊[New Chat]
- 輸入prompt時，AI提示輸入「對p2.jpg做OCR」

這種方式進一步減輕使用者的認知負擔，但仍保留自主決策權。

#### 3. AI建議多個Prompts (MVP不考慮)

- 使用者：「對p1.jpg做OCR」
- AI產出結果
- 使用者點擊[New Chat]
- 輸入prompt時，AI提示多個選項：
  - 「對p2.jpg做OCR」
  - 「(command: new chat: 對p3.jpg做OCR)」
  - 「(command: new chat: 對p4.jpg做OCR)」

這種方式提供更多自動化可能性，但需要更複雜的實現。

這些半自動化方法的核心理念是：「讓AI推動工作流程，但使用者保持最終控制權」。這種平衡既能提高效率，又能確保輸出品質符合使用者期望。

對於重複性強的任務，系統還允許將已優化的工作流保存下來，便於下次直接重用或微調，進一步提高工作效率。

## Q12: 為什麼我們選擇半自動而非完全自動化設計？

選擇半自動化設計而非完全自動化，是基於對實際工作流程和使用者心理的深入理解：

### 品質控制

AI技術雖然強大，但尚未達到能夠完全替代人類判斷的水準。在創意工作、關鍵決策和品質要求高的場景中，人類的參與仍是不可或缺的。半自動化設計讓使用者能在關鍵節點進行審核和調整，確保最終產出符合預期。

### 使用者心理接受度

完全自動化系統常常給使用者帶來「失控感」，特別是在處理重要任務時。半自動化設計保留了使用者的決策權，降低了使用的心理門檻，增強了使用者對系統的信任。

### 逐步優化的機會

AI自動生成的結果往往需要多次調整和優化。半自動化流程中的每一步都提供了修正和改進的機會，讓結果更符合使用者需求。正如我在設計理念中提到的：「修改」總比「從零開始」簡單。

### 實際案例

以UI開發為例，與AI合作時，工作通常需要分階段進行：

1. 討論需求和方向
2. 生成初步設計
3. 審核並調整設計
4. 實現主要功能
5. 測試
6. 優化和調整

在這個過程中，每一步都需要人類的判斷和決策。完全自動化難以應對這種複雜的反饋循環。

### 使用者體驗設計理念

「Push not pull」的核心是減輕使用者的認知負擔，但不是完全取代使用者的參與。我們設計的系統像一個積極主動的助手，而不是一個獨立的工作者—它會推動工作流程，但尊重使用者的決策權。

總之，半自動化設計在效率和控制之間找到了更好的平衡點，特別適合知識工作者的工作流程，讓AI真正成為使用者的得力助手，而不是一個可能帶來不確定性的黑盒子。
