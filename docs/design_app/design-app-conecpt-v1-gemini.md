好的，沒問題！身為這個 App 的設計者，很高興能跟你聊聊我們的設計想法。我試著用 Q&A 的方式，把最新的設計概念 (`design-app-conecpt.md` 裡面的內容) 梳理清楚，讓你，還有未來可能加入的夥伴們，能夠快速進入狀況。我會盡量講得白話一點，帶入一些我們當初思考的脈絡，希望讓你感覺就像我們在對話一樣。

---

### **Q1: 這個 App 到底想解決什麼問題啊？感覺市面上 AI 工具已經很多了？**

**A:**
問得很好！其實這個 App 的起點很單純，就是來自我們（或者說，主要是我啦）在日常使用 AI 協助工作時遇到的**痛點**。 [Source 1]

你看喔，我們有時候就是會**懶**、覺得**時間不夠用**，或者事情一多就**忙不過來**。很多工具都需要你「主動」去操作、去問、去觸發，但老實說，有時候我希望的是 AI 能**「推」著我走**，而不是我一直去「拉」著 AI。

舉個例子，你有沒有過這種經驗：好不容易完成一個階段性任務，像是設計完一個頁面，或是整理好一些資料，然後突然就...卡住了？不知道下一步要做啥，或是單純就是累了，想耍廢一下。這時候如果有個機制能**自動建議或啟動下一步**，讓我回來時能看到一些初步成果，那該有多好？ [Source 1, 2]

另外，在用 AI 輔助開發（像是寫 Code 或 UI 設計）時，常常會發現：

1.  **管理對話很麻煩：** 對話一長，AI 效果就變差，常常需要把階段性成果（比如產生的文件、程式碼片段）複製出來，開一個新對話重新貼進去，才能繼續。 [Source 1]
2.  **檔案管理不易：** 常常需要把檔案內容複製貼上給 AI，或是反過來，很瑣碎。 [Source 1]
3.  **工作流程難以複用：** 有些工作是重複性的，比如我花了很多時間跟 AI 來回溝通、調整 Prompt，才得到一個很滿意的翻譯或摘要流程。下次有類似需求時，我只想換個輸入檔案，然後「重跑」這個優化過的流程，而不是每次都重來。 [Source 1, 2]

所以，這個 App 的核心目標，就是想解決這些「懶」、「管理不易」、「流程難複用」的問題，打造一個更符合我們實際工作習慣的 AI 協作環境。

---

### **Q2: 你一直提到「Push not Pull」，這是什麼意思？是這個 App 的核心設計理念嗎？**

**A:**
沒錯！「**Push not Pull**」可以說是我們最核心的設計哲學。 [Source 2]

你想想看，傳統的工作方式比較像是「Pull」，也就是「拉取」：你需要資訊時，你去搜尋；你需要執行某個動作時，你主動去點擊按鈕。

但我們想要的是「Push」，也就是「推送」：想像你有個 AI 秘書，你主要的工作是**下達指令**和**審核結果**。例如，你早上來，打開 App 的 Dashboard，看到 AI 已經幫你跑了一些進度，現在需要你 Review 或 Approve 幾個步驟。你確認 OK 之後，AI 就自動接手，繼續往下跑。 [Source 2]

當你有一個新任務時，你只需要給出大概的方向和指示，AI 可能會跟你確認一些細節，然後它就自己去規劃、執行。你不用時時刻刻去盯著它、催促它。這種感覺就像是 AI 在「推」著專案前進，而你扮演的是決策者和把關者的角色。

這個理念也體現在「**下一步（Next Step）**」的設計上。當你完成一個任務，感到有點茫然或想偷懶時，系統能主動建議下一步，甚至幫你準備好下個任務的草稿，你只要按個鈕，AI 就開始跑，你去休息一下，回來再看成果。 [Source 2] 這樣是不是感覺輕鬆多了？「修改」總比「從零開始」容易嘛！

---

### **Q3: 聽起來有點像現在很紅的 AI Agent System？你們這個跟那些有什麼不一樣？**

**A:**
這是個好問題！確實有些相似之處，但我們的側重點很不一樣。 [Source 2]

主要的差別在於：

1.  **半自動 vs. 全自動：** 現在很多 Agent System 追求的是「全自動」，你給一個目標，它就自己跑到結束。但我們認為，在很多真實工作情境下，「**半自動**」反而更實用。例如，開發時遇到問題，問了 AI 得到解法，我通常會想基於這個解法去實作，而不是讓 AI 一路幫我寫到底。我需要的是在過程中可以**介入、調整、確認**的彈性。 [Source 2]
2.  **可追蹤、可修改、可重複利用：** 我們非常強調「**工作流（Workflow）**」的概念。你在跟 AI 互動、調整 Prompt、處理檔案的過程，其實就是在打造一個工作流程。我們希望這個流程是可以被**記錄下來、追蹤進度、隨時修改、並且可以重複利用**的。例如你那個優化過的「翻譯+摘要」流程，下次可以直接拿出來，換個輸入就跑。這更像是一個「**可高度編輯的 AI 工作流編輯器 + 執行器**」，而不單純是一個黑盒子的全自動 Agent。 [Source 2]

所以，你可以把我們的 App 想成是一個**以 Task 和 Chat 為基礎的 AI 工作流管理與執行平台**，它有 Agent 的潛力，但更強調過程的可控性與流程的複用性。

---

### **Q4: 那具體來說，這個 App 的架構是怎麼設計的？像是檔案、任務是怎麼管理的？**

**A:**
我們採用了大家都很熟悉的**檔案總管（Folder Structure）**概念來組織工作。 [Source 3]

想像你的根目錄就是一個 **Workspace**（或叫 Project，名字還沒完全定案 [Source 5]）。

```
/(Workspace) 我的專案名稱
├── /(Task) 任務一：資料收集與整理
│   ├── task.json             <-- 這個檔案標示這是一個 Task Folder
│   ├── chat_01.v1681886400.json <-- 這是跟 AI 的對話紀錄
│   ├── chat_02.v1681887000.json <-- 另一個對話
│   ├── reference_doc.pdf     <-- 任務相關的檔案
│   └── artifact_summary.v1681887600.md <-- AI 產生的結果 (Artifact)
│
├── /(Task) 任務二：根據整理結果設計架構
│   ├── task.json
│   ├── (entrypoint) chat_design.v1681890000.json <-- 引用任務一的成果
│   ├── artifact_architecture.v1681891200.md
│   └── /(Task) 子任務：設計資料庫 Schema  <-- Task 底下還可以有子 Task
│       ├── task.json
│       └── ...
│
├── /Other_Files             <-- 其他非 Task 的一般資料夾或檔案
│   └── meeting_notes.txt
│
└── [New Chat Button]         <-- 在 Workspace 層級也能快速開啟新對話
```

這裡有幾個關鍵點：

1.  **Workspace/Project:** 就是最外層的那個資料夾，代表你的整個專案。
2.  **Task:** 也是一個**資料夾**。我們用一個特殊的 `task.json` 檔案來識別它。這個檔案未來可能也會儲存 Task 的一些設定或狀態。 [Source 5] 因為 Task 本身是資料夾，所以你可以很自然地在 Task 裡面再建立 Task，形成**子任務（Subtasks）**的結構。 [Source 5]
3.  **Chat:** 代表你跟 AI 的一次或一系列對話。我們會把它存成 JSON 檔案，檔名類似 `chat_{id_or_title}.{timestamp}.json`。 [Source 5]
    - `chat_` 前綴方便識別。
    - `{id_or_title}` 可以是流水號或是有意義的標題，方便查找。
    - `{timestamp}` 是檔案建立的時間戳，這很重要，因為當你修改或重新生成對話時，我們會**保留舊版本**，用 timestamp 來做**版本控制**。你隨時可以回溯去看之前的對話長怎樣。 [Source 3]
4.  **Artifact:** 指的是 AI 在執行任務過程中產生的**主要成果**，比如整理好的文件、設計稿、程式碼片段等等。我們會用 `artifact_` 這樣的前綴來標示。 [Source 4]
5.  **檔案引用:** 如果你需要讓 AI 參考某個檔案，可以直接在 Prompt 中使用類似 `#檔案路徑` 的語法來注入。這讓跨 Task 或引用外部檔案變得很方便。 [Source 7]

這樣的設計，我們覺得好處是**直觀**，跟你平常管理電腦檔案的邏輯很像，學習成本低。同時，基於資料夾和檔案，未來要做版本控制、分享、搜尋等功能，也會比較單純。

---

### **Q5: 什麼是「Chat」？為什麼一個 Task 裡可以有多個 Chats？**

**A:**
「**Chat**」基本上就是你跟 AI 互動的介面和紀錄。 [Source 8] 你可以在這裡輸入 Prompt，選擇想用的 AI 模型（比如 Claude 3.7 [Source 8]），然後跟 AI 對話。

一個 Chat 不只是簡單的問答，它也可以包含 **Function Calling**，也就是讓 AI 可以呼叫外部工具或執行特定動作，形成像 `User -> Agent (call function) -> System (function result) -> Agent (generate response) -> User` 這樣的互動循環。 [Source 8]

那為什麼一個 Task 資料夾裡可以放很多個 Chat 檔案呢？ [Source 9]

1.  **區分主要任務與輔助討論：** 有時候，一個 Task 的核心可能是一個主要的 Chat，用來生成最終產出（Artifact）。但過程中，你可能會有其他疑問，想跟 AI 做一些**周邊的討論或查詢**。比如 AI 幫你寫了一封英文 Email (主要 Chat)，但你對其中某個詞的用法不太確定，想另外開一個 Chat 問清楚。這個額外的 Chat 雖然跟任務相關，但並不是產生最終 Email 的那個流程，把它們分開管理會比較清晰。 [Source 9]
2.  **將複雜任務拆解成步驟 (Chat Chain)：** 對於一些需要多步驟才能完成的任務，可以把每一步拆成一個獨立的 Chat。 [Source 10]

    - 例如，「對掃描的書本做 OCR 並翻譯」：
      - Chat 1: `對 p1.jpg 做 OCR & 翻譯`
      - Chat 2: `對 p2.jpg 做 OCR & 翻譯`
      - Chat 3: `對 p3.jpg 做 OCR & 翻譯`
    - 例如，「根據設計稿逐步寫 Code」：
      - Chat 1: `現在已完成：(空白)，請寫：第一個 Class`
      - Chat 2: `現在已完成：第一個 Class，請寫：相關的 Function`
      - Chat 3: `現在已完成：第一個 Class, 相關的 Function，請寫：測試案例`

    這種把任務拆成一系列連續 Chat 的方式，我們內部稱之為「**Chat Chain**」。 [Source 10]

所以，允許多個 Chats 提供了一種**彈性**，讓你可以根據任務的複雜度和自己的工作習慣，來組織與 AI 的互動。

---

### **Q6: 那「Run Task」是做什麼的？如果 Task 或 Chat 有相依性或順序性，會怎麼處理？**

**A:**
「**Run Task**」顧名思義，就是執行一個任務。在我們的設計想像中，Task 資料夾旁邊可能會有個「**Run Button**」。 [Source 4]

不過，關於執行的細節，我們在 MVP (Minimum Viable Product，最小可行性產品) 階段會採取比較**簡單直接 (Naive)** 的做法：

1.  **執行單一 Task:** 你點哪個 Task 的 Run Button，就執行哪個 Task。我們**暫時不處理 Task 之間的依賴關係**。就算任務二需要任務一的產出，也需要你手動先跑完任務一，再跑任務二。未來或許可以根據 Task 之間的檔案引用關係，建立一個**依賴圖 (Dependency Run Graph)**，做到更智慧的執行或推薦，但 MVP 階段先不考慮。 [Source 4, 6]
2.  **執行 Task 下的所有內容 (Naive):** 如果一個 Task 資料夾底下有多個子任務或多個 Chats，最簡單的執行方式就是**按照檔案/資料夾的順序依次執行**。 [Source 6, 9]
    - 例如，`/Task1` 底下有 `/Task2`, `/Task3`, `chat_A.json`。Naive 的執行順序可能是 `Task1 本身的 Chat (如果有的話) -> Task2 -> Task3 -> chat_A.json` (或是某種預設排序)。 [Source 6]
3.  **執行 Chat Chain:** 對於前面提到的 Chat Chain（一個 Task 下有多個需要依序執行的 Chats），Naive 的做法也是不分青紅皂白，**按照順序把所有 Chat 都跑一遍**。 [Source 9]

我們知道這種 Naive 的做法不夠聰明。理想上，使用者應該可以**選擇**哪些 Chats 需要被執行、**指定執行順序**，甚至標示出哪個 Chat 是產生主要 Artifact 的「入口點 (Entrypoint)」。 [Source 4, 9] 但為了快速驗證核心概念，我們打算先把執行機制做得簡單點，未來再逐步優化。

---

### **Q7: 如何提供 Task 需要的背景知識或檔案 (Task Knowledge) 給 AI？**

**A:**
這是個很重要的問題！AI 要能好好工作，常常需要很多背景資訊或上下文 (Context)。我們討論了幾種方案，目前比較傾向的做法是**整合在 Prompt** 裡，但提供一些語法糖來方便管理。

一開始我們想過用特定資料夾（比如 `/task_knowledge`）[Source 6] 或是在 UI 上勾選檔案 [Source 6]，但後來覺得，直接在 Prompt 裡控制可能更靈活。

目前的想法是，可以在 Prompt 中使用類似 XML 的標籤來定義 Task Knowledge：[Source 7]

```xml
<task_knowledge>
  #p1.jpg
  #p2.jpg
  #../shared_utils/*.py  <-- 甚至可以用萬用字元 (wild card)
  #artifact_previous_summary.md <-- 引用其他 Task 的產出
</task_knowledge>

<task_instruction>
  請總結 <task_knowledge> 中提到的所有圖片內容，並參考 utils 裡面的格式化函數，輸出成 Markdown 格式。
  輸出的檔名請設為 artifact_image_summary.md。
</task_instruction>

請開始執行任務。
```

這樣做的好處是：

1.  **明確性：** 非常清楚這個 Task 執行時會參考哪些知識。
2.  **靈活性：** 可以很容易地透過複製貼上、修改 Prompt 來調整 Knowledge。比如 Chat 1v1 用 `#a.py`，Chat 1v2 想多加一個檔案就改成 `#a.py #b.py`，同時保留 Chat 1v1 的版本。 [Source 7]
3.  **整合性：** 把 Knowledge 和 Instruction 放在一起，管理上比較集中。

我們也考慮**預設**將 Task 資料夾內（不含子資料夾）的所有非 Chat、非 Task 的檔案**自動**納入 `<task_knowledge>`，使用者可以在 Prompt 裡覆寫或增減。 [Source 7] 這些 Knowledge 的設定也可能會記錄在 `task.json` 中。 [Source 7]

---

### **Q8: 那個 Chat Panel 的輸入框設計有什麼特別的嗎？**

**A:**
嗯，我們針對 Chat Panel 的輸入框也思考了一些互動細節。 [Source 8] 想像一下，輸入框下方大概會長這樣：

```
(這裡是文字輸入區域)
--------------------------------------------------|
|                                                 |
|                                                 |
--------------------------------------------------|
[Agent] [New Task]    [Claude 3.7 ▼]    [Submit >]
```

這裡的幾個按鈕：

- **`[Agent]`**: 這是一個可選按鈕 (selectable button / radio button)。選中它的話，表示你希望這次提交的 Prompt 是交由一個 Agent (如果未來實現了 Agent 模式的話) 來處理，而不只是一般的問答。MVP 初期可能先不實作 Agent 模式。 [Source 8, 9]
- **`[New Task]`**: 這也是一個可選按鈕。如果**選中**這個按鈕再按 `Submit`，那麼你剛輸入的 Prompt 會被用來**建立一個全新的 Task 資料夾**，而這個 Chat 就會是該 Task 的第一個 Chat 檔案 (`chat_01...json`)，同時也會生成 `task.json`。如果你**沒有選中**它，那這次提交就只會生成一個新的 Chat 檔案 (`chat_xx...json`)，放在當前的 Task 或 Workspace 底下。 [Source 8]
- **`[Claude 3.7 ▼]`**: 這裡是讓你選擇要使用哪個 AI 模型。
- **`[Submit >]`**: 就是送出你的輸入啦。

這樣的設計是希望把「創建新任務」這個常用的動作，直接整合到對話輸入流程中，讓使用者可以很流暢地從一個想法或討論，直接開啟一個新的工作單元 (Task)。

---

### **Q9: 對於重複性任務，像是你前面提到的 OCR 掃描檔，App 能做到什麼程度的自動化？**

**A:**
對於重複性任務的自動化，我們設想了幾種不同層次的做法，從半自動到全自動：[Source 10]

1.  **全自動 (Agent 模式 - 未來考量):** 你可以開啟 Agent 模式，給一個指令，例如「幫我把這個資料夾裡所有的圖片都做 OCR 並翻譯成繁體中文」。AI Agent 會自己分析、規劃步驟、循環執行（一張一張處理），最後給你整理好的結果。這需要比較成熟的 Agent 能力，MVP 階段先不納入。 [Source 10]
2.  **半自動 (使用「下一步」按鈕):** 這是我們 MVP 可能會著重實現的功能。你手動執行第一個 Chat：「對 p1.jpg 做 OCR」。AI 產生結果後，你檢查 OK，然後點擊一個類似「**下一步 (Next Step)**」的按鈕。AI 會根據上一個 Chat 的模式，**自動生成下一個 Task 或 Chat 的草稿**，例如自動填好 Prompt：「對 p2.jpg 做 OCR」。你只需要確認一下，按下「Run Task」或「Submit」，AI 就接著跑下一張圖片。這樣雖然還是需要你手動觸發下一步，但已經省去了自己複製貼上、修改 Prompt 的麻煩。 [Source 2, 10]
3.  **半自動 (AI 建議 Prompt - 未來考量):** 當你點擊「New Chat」準備輸入下一個步驟時，AI 根據上下文**主動提示**你可能想輸入的 Prompt。例如，你剛做完 `p1.jpg` 的 OCR，點 New Chat，AI 就在輸入框提示「對 p2.jpg 做 OCR」。 [Source 10]
4.  **半自動 (AI 建議多個 Prompts - 未來考量):** 更進階一點，AI 不只建議下一步，甚至可以一次建議多個步驟，讓你一次創建好幾個 Chats 或 Tasks。例如，提示「對 p2.jpg 做 OCR (同時創建新 Chat: 對 p3.jpg 做 OCR) (同時創建新 Chat: 對 p4.jpg 做 OCR)」。 [Source 10]

總之，我們的目標是讓使用者可以根據自己的需求和任務的性質，選擇不同程度的自動化。從最基本的 Chat Chain 手動執行，到半自動的「下一步」輔助，乃至未來可能的全自動 Agent，逐步提升處理重複性工作的效率。

---

希望以上的 Q&A 能讓你對這個 App 的設計理念和核心功能有更清楚的了解。我們的設計還在持續演進中，尤其是很多細節和未來功能（像是 Agent、Run Graph、更智慧的下一步建議等），都還需要更多的討論和驗證。但核心的「Push not Pull」哲學，以及透過 Task 和 Chat 來管理、執行、複用 AI 工作流的想法，是我們目前努力的方向。如果你有任何想法或疑問，隨時都可以提出來一起討論喔！
